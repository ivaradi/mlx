diff --git a/com/win32com/src/ErrorUtils.cpp b/com/win32com/src/ErrorUtils.cpp
index 1186cd1..314aff8 100644
--- a/com/win32com/src/ErrorUtils.cpp
+++ b/com/win32com/src/ErrorUtils.cpp
@@ -1118,9 +1118,15 @@ LPCTSTR GetScodeRangeString(HRESULT hr)
 		HRESULT hrLast;
 		LPCTSTR lpszName;
 	};
+#if defined(__MINGW32__)
+	#define MAKE_RANGE_ENTRY(hrRange) \
+                { static_cast<HRESULT>(hrRange##_FIRST), static_cast<HRESULT>(hrRange##_LAST), \
+			_T(#hrRange) _T("_FIRST...") _T(#hrRange) _T("_LAST") }
+#else
 	#define MAKE_RANGE_ENTRY(hrRange) \
 		{ hrRange##_FIRST, hrRange##_LAST, \
 			_T(#hrRange) _T("_FIRST...") _T(#hrRange) _T("_LAST") }
+#endif
 
 	static const RANGE_ENTRY hrRangeTable[] =
 	{
diff --git a/com/win32com/src/PyGatewayBase.cpp b/com/win32com/src/PyGatewayBase.cpp
index fc091cb..2ed9acc 100644
--- a/com/win32com/src/PyGatewayBase.cpp
+++ b/com/win32com/src/PyGatewayBase.cpp
@@ -7,6 +7,10 @@
 
 #include "PythonCOMServer.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
+
 // {25D29CD0-9B98-11d0-AE79-4CF1CF000000}
 extern const GUID IID_IInternalUnwrapPythonObject = 
 	{ 0x25d29cd0, 0x9b98, 0x11d0, { 0xae, 0x79, 0x4c, 0xf1, 0xcf, 0x0, 0x0, 0x0 } };
@@ -437,7 +441,11 @@ static HRESULT invoke_setup(
 		// make sure its not a special DISPID we don't understand.
 		if (params->rgdispidNamedArgs[i] < 0)
 			return DISP_E_PARAMNOTFOUND;
+#if defined(__MINGW32__)
+		numArgs = std::max(numArgs, (UINT)params->rgdispidNamedArgs[i]+1);
+#else
 		numArgs = max(numArgs, (UINT)params->rgdispidNamedArgs[i]+1);
+#endif
 	}
 
 	PyObject *argList = PyTuple_New(numArgs);
@@ -658,7 +666,11 @@ static HRESULT invoke_finish(
 			ob = NULL;
 			firstByRef = 1;
 		}
+#if defined(__MINGW32__)
+		UINT max_args = std::min(cUserResult-firstByRef, pDispParams->cArgs);
+#else
 		UINT max_args = min(cUserResult-firstByRef, pDispParams->cArgs);
+#endif
 		UINT *offsets = (UINT *)_malloca(sizeof(UINT) * max_args);
 		// Get the offsets into our params of all BYREF args, in order.
 		fill_byref_offsets(pDispParams, offsets, max_args);
diff --git a/com/win32com/src/PythonCOM.cpp b/com/win32com/src/PythonCOM.cpp
index da00839..67983a4 100644
--- a/com/win32com/src/PythonCOM.cpp
+++ b/com/win32com/src/PythonCOM.cpp
@@ -342,11 +342,13 @@ static PyObject *pythoncom_CoInitializeSecurity(PyObject *self, PyObject *args)
 			pSD = (PSECURITY_DESCRIPTOR)&appid;
 			}
 		}
+#if !defined(__MINGW32__)
 	else if (dwCapabilities & EOAC_ACCESS_CONTROL){
 		if (!PyCom_InterfaceFromPyObject(obSD, IID_IAccessControl, (void **)&pIAC, FALSE))
 			return NULL;
 		pSD = (PSECURITY_DESCRIPTOR)pIAC;
 		}
+#endif
 	else{
 		if (!PyWinObject_AsSECURITY_DESCRIPTOR(obSD, &pSD, /*BOOL bNoneOK = */TRUE))
 			return NULL;
diff --git a/com/win32com/src/PythonCOM.def b/com/win32com/src/PythonCOM.def
index 58d030f..6d2a54b 100644
--- a/com/win32com/src/PythonCOM.def
+++ b/com/win32com/src/PythonCOM.def
@@ -1,15 +1,15 @@
 EXPORTS
-	DllCanUnloadNow     @1 PRIVATE
-	DllGetClassObject   @2 PRIVATE
+	DllCanUnloadNow
+	DllGetClassObject
 
 	; Some exports for clients who may "LoadLibrary"...
-	PyCom_VariantFromPyObject
-	PyCom_PyObjectFromVariant
-	PyCom_InterfaceFromPyObject
-	PyCom_PyObjectFromIUnknown
-	PyCom_MakeOlePythonCall
+	_PyCom_VariantFromPyObject
+	_PyCom_PyObjectFromVariant
+	_PyCom_InterfaceFromPyObject
+	_PyCom_PyObjectFromIUnknown
+	_PyCom_MakeOlePythonCall
 
-	PyCom_CoInitializeEx
-	PyCom_CoInitialize
-	PyCom_CoUninitialize
+	_PyCom_CoInitializeEx
+	_PyCom_CoInitialize
+	_PyCom_CoUninitialize
 
diff --git a/com/win32com/src/Register.cpp b/com/win32com/src/Register.cpp
index 0b24ee2..d259aff 100644
--- a/com/win32com/src/Register.cpp
+++ b/com/win32com/src/Register.cpp
@@ -322,7 +322,9 @@ static const PyCom_InterfaceSupportInfo g_interfaceSupportData[] =
 	PYCOM_INTERFACE_FULL	   ( CancelMethodCalls),
 	// No wrapper for IAccessControl yet, but you can still get the system implementation
 	//  by calling pythoncom.CoCreateInstance with IID_IUnknown as the returned interface
+#if !defined(__MINGW32__)
 	PYCOM_INTERFACE_CLSID_ONLY (DCOMAccessControl),
+#endif
 
 	// NULL, Unknown and dispatch special cases.
 	{ &IID_NULL, "Null", "IID_NULL", NULL, NULL},
diff --git a/com/win32com/src/dllmain.cpp b/com/win32com/src/dllmain.cpp
index fb81ddb..abf074c 100644
--- a/com/win32com/src/dllmain.cpp
+++ b/com/win32com/src/dllmain.cpp
@@ -175,6 +175,9 @@ typedef HRESULT (WINAPI *PFNCoInitializeEx)(LPVOID pvReserved, DWORD dwCoInit);
 // the Init for Term function explicitely, and the framework will detect
 // it no longer needs doing.
 // XXX - Needs more thought about threading implications.
+#if defined(__MINGW32__)
+extern "C"
+#endif
 HRESULT PyCom_CoInitializeEx(LPVOID reserved, DWORD dwInit)
 {
 	// Must be thread-safe, although doesnt need the Python lock.
diff --git a/com/win32com/src/include/PythonCOM.h b/com/win32com/src/include/PythonCOM.h
index 9e422e4..f3b1063 100644
--- a/com/win32com/src/include/PythonCOM.h
+++ b/com/win32com/src/include/PythonCOM.h
@@ -111,10 +111,8 @@
 #ifdef __MINGW32__
 // Special Mingw32 considerations.
 #define NO_PYCOM_IDISPATCHEX
-#define NO_PYCOM_IPROVIDECLASSINFO
 #define NO_PYCOM_ISERVICEPROVIDER
 #define NO_PYCOM_ENUMSTATPROPSTG
-#define NO_PYCOM_IPROPERTYSTORAGE
 #define __try try
 #define __except catch
 #include <olectl.h>
@@ -305,6 +303,9 @@ PYCOM_EXPORT PyObject *PyObject_FromOLEMENUGROUPWIDTHS(const OLEMENUGROUPWIDTHS
 
 /* Functions for Initializing COM, and also letting the core know about it!
 */
+#if defined(__MINGW32__)
+extern "C"
+#endif
 PYCOM_EXPORT HRESULT PyCom_CoInitializeEx(LPVOID reserved, DWORD dwInit);
 PYCOM_EXPORT HRESULT PyCom_CoInitialize(LPVOID reserved);
 PYCOM_EXPORT void PyCom_CoUninitialize();
diff --git a/com/win32com/src/initguid.cpp b/com/win32com/src/initguid.cpp
new file mode 100644
index 0000000..33d5923
--- /dev/null
+++ b/com/win32com/src/initguid.cpp
@@ -0,0 +1,7 @@
+#define INITGUID
+#undef _OBJIDLBASE_
+#define CINTERFACE
+#define USE_COM_CONTEXT_DEF
+#include <objidl.h>
+#include <ksguid.h>
+#include <ks.h>
diff --git a/com/win32comext/axcontrol/src/PyIOleCommandTarget.cpp b/com/win32comext/axcontrol/src/PyIOleCommandTarget.cpp
index 61bd706..e7908e9 100644
--- a/com/win32comext/axcontrol/src/PyIOleCommandTarget.cpp
+++ b/com/win32comext/axcontrol/src/PyIOleCommandTarget.cpp
@@ -4,6 +4,10 @@
 #include "axcontrol_pch.h"
 #include "PyIOleCommandTarget.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
+
 static BOOL FillOLECMDsWithSequence(OLECMD *pCmds, UINT ncmds, PyObject *obCmds)
 {
 	for (UINT i=0;i<ncmds;i++) {
@@ -211,7 +215,11 @@ STDMETHODIMP PyGOleCommandTarget::QueryStatus(
 			ok = PyWinObject_AsAutoFreeBstr(obText, &tempString);
 			if (ok) {
 				UINT strLen = SysStringLen(tempString);
+#if defined(__MINGW32__)
+				UINT nwrite = std::min((ULONG)strLen, pCmdText->cwBuf);
+#else
 				UINT nwrite = min(strLen, pCmdText->cwBuf);
+#endif
 				wcsncpy(pCmdText->rgwz, (WCHAR *)(BSTR)tempString,
 					nwrite);
 				pCmdText->cwActual = nwrite;
diff --git a/com/win32comext/axcontrol/src/initguid.cpp b/com/win32comext/axcontrol/src/initguid.cpp
new file mode 100644
index 0000000..329e211
--- /dev/null
+++ b/com/win32comext/axcontrol/src/initguid.cpp
@@ -0,0 +1,8 @@
+#define INITGUID
+#undef _OBJIDLBASE_
+#define CINTERFACE
+#define USE_COM_CONTEXT_DEF
+#include <objidl.h>
+#include <ksguid.h>
+#include <ks.h>
+#include <docobj.h>
diff --git a/com/win32comext/axscript/src/initguid.cpp b/com/win32comext/axscript/src/initguid.cpp
new file mode 100644
index 0000000..ba6baa3
--- /dev/null
+++ b/com/win32comext/axscript/src/initguid.cpp
@@ -0,0 +1,8 @@
+#define INITGUID
+#undef _OBJIDLBASE_
+#define CINTERFACE
+#define USE_COM_CONTEXT_DEF
+#include <objidl.h>
+#include <ksguid.h>
+#include <ks.h>
+#include <objsafe.h>
diff --git a/com/win32comext/internet/src/PyIInternetProtocol.cpp b/com/win32comext/internet/src/PyIInternetProtocol.cpp
index 43c25a8..b910c85 100644
--- a/com/win32comext/internet/src/PyIInternetProtocol.cpp
+++ b/com/win32comext/internet/src/PyIInternetProtocol.cpp
@@ -5,6 +5,10 @@
 #include "PyIInternetProtocolRoot.h"
 #include "PyIInternetProtocol.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
+
 // @doc - This file contains autoduck documentation
 // ---------------------------------------------------
 //
@@ -181,7 +185,11 @@ STDMETHODIMP PyGInternetProtocol::Read(
 		hr = PyCom_HandlePythonFailureToCOM();
 	} else {
 		char *buf = PyString_AsString(result);
+#if defined(__MINGW32__)
+		*pcbRead = std::min(cb, (ULONG)PyString_Size(result));
+#else
 		*pcbRead = min(cb, (ULONG)PyString_Size(result));
+#endif
 		memcpy( pv, buf, *pcbRead);
 	}
 	return hr;
diff --git a/com/win32comext/internet/src/PyIInternetProtocolInfo.cpp b/com/win32comext/internet/src/PyIInternetProtocolInfo.cpp
index c00e43e..ef894ca 100644
--- a/com/win32comext/internet/src/PyIInternetProtocolInfo.cpp
+++ b/com/win32comext/internet/src/PyIInternetProtocolInfo.cpp
@@ -4,6 +4,10 @@
 #include "internet_pch.h"
 #include "PyIInternetProtocolInfo.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
+
 // @doc - This file contains autoduck documentation
 // ---------------------------------------------------
 //
@@ -226,7 +230,11 @@ STDMETHODIMP PyGInternetProtocolInfo::ParseUrl(
 	if (!PyWinObject_AsBstr(result, &bstrTemp, FALSE, pcchResult)) bPythonIsHappy = FALSE;
 	if (!bPythonIsHappy) return PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
 	++(*pcchResult); // Null terminator
+#if defined(__MINGW32__)
+	*pcchResult = std::min(*pcchResult, cchResult);
+#else
 	*pcchResult = min(*pcchResult, cchResult);
+#endif
 	memcpy(pwzResult, bstrTemp, *pcchResult * sizeof(WCHAR));
 	SysFreeString(bstrTemp);
 	Py_DECREF(result);
@@ -258,7 +266,11 @@ STDMETHODIMP PyGInternetProtocolInfo::CombineUrl(
 	if (!PyWinObject_AsBstr(result, &bstrTemp, FALSE, pcchResult)) bPythonIsHappy = FALSE;
 	if (!bPythonIsHappy) hr = PyCom_HandlePythonFailureToCOM(/*pexcepinfo*/);
 	++(*pcchResult); // Null terminator
+#if defined(__MINGW32__)
+	*pcchResult = std::min(*pcchResult, cchResult);
+#else
 	*pcchResult = min(*pcchResult, cchResult);
+#endif
 	memcpy(pwzResult, bstrTemp, *pcchResult * sizeof(WCHAR));
 	SysFreeString(bstrTemp);
 	Py_DECREF(result);
@@ -312,7 +324,11 @@ STDMETHODIMP PyGInternetProtocolInfo::QueryInfo(
 			return PyCom_HandlePythonFailureToCOM();
 		}
 	} else {
+#if defined(__MINGW32__)
+		*pcbBuf = std::min(cbBuffer, (ULONG)PyString_Size(result));
+#else
 		*pcbBuf = min(cbBuffer, (ULONG)PyString_Size(result));
+#endif
 		memcpy(pBuffer, PyString_AsString(result), *pcbBuf);
 	}
 	Py_DECREF(result);
diff --git a/com/win32comext/internet/src/PyIInternetSecurityManager.cpp b/com/win32comext/internet/src/PyIInternetSecurityManager.cpp
index 81439fc..a4cb106 100644
--- a/com/win32comext/internet/src/PyIInternetSecurityManager.cpp
+++ b/com/win32comext/internet/src/PyIInternetSecurityManager.cpp
@@ -4,6 +4,10 @@
 #include "internet_pch.h"
 #include "PyIInternetSecurityManager.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
+
 // @doc - This file contains autoduck documentation
 // ---------------------------------------------------
 //
@@ -338,7 +342,11 @@ STDMETHODIMP PyGInternetSecurityManager::GetSecurityId(
 		Py_DECREF(result);
 		return MAKE_PYCOM_GATEWAY_FAILURE_CODE("GetSecurityId");
 	}
+#if defined(__MINGW32__)
+	*pcbSecurityId = std::min(buf_len, *pcbSecurityId);
+#else
 	*pcbSecurityId = min(buf_len, *pcbSecurityId);
+#endif
 	memcpy(pbSecurityId, buf, *pcbSecurityId);
 	Py_DECREF(result);
 	return hr;
diff --git a/com/win32comext/internet/src/initguid.cpp b/com/win32comext/internet/src/initguid.cpp
new file mode 100644
index 0000000..1003585
--- /dev/null
+++ b/com/win32comext/internet/src/initguid.cpp
@@ -0,0 +1,9 @@
+#define INITGUID
+#undef _OBJIDLBASE_
+#define CINTERFACE
+#define USE_COM_CONTEXT_DEF
+#include <objidl.h>
+#include <ksguid.h>
+#include <ks.h>
+#include <urlmon.h>
+#include <mshtmhst.h>
diff --git a/com/win32comext/propsys/src/PyPROPVARIANT.cpp b/com/win32comext/propsys/src/PyPROPVARIANT.cpp
index b330129..694703f 100644
--- a/com/win32comext/propsys/src/PyPROPVARIANT.cpp
+++ b/com/win32comext/propsys/src/PyPROPVARIANT.cpp
@@ -3,7 +3,13 @@
 
 #include "PythonCOM.h"
 #include "PyPROPVARIANT.h"
+#if defined(__MINGW32__)
+extern "C" {
+#endif
 #include "propvarutil.h"
+#if defined(__MINGW32__)
+}
+#endif
 #include "float.h"
 
 // @doc - This file contains autoduck documentation
diff --git a/com/win32comext/propsys/src/propsys.cpp b/com/win32comext/propsys/src/propsys.cpp
index ef0a2f4..69ff21f 100644
--- a/com/win32comext/propsys/src/propsys.cpp
+++ b/com/win32comext/propsys/src/propsys.cpp
@@ -279,6 +279,7 @@ static PyObject *PyPSGetItemPropertyHandler(PyObject *self, PyObject *args)
 	return PyCom_PyObjectFromIUnknown((IUnknown *)propertystore, riid, FALSE);
 }
 
+#if !defined(__MINGW32__)
 // @pymethod bytes|propsys|StgSerializePropVariant|Serializes a <o PyPROPVARIANT>
 static PyObject *PyStgSerializePropVariant(PyObject *self, PyObject *args)
 {
@@ -319,6 +320,7 @@ static PyObject *PyStgDeserializePropVariant(PyObject *self, PyObject *args)
 		return PyCom_BuildPyException(hr);
 	return PyWinObject_FromPROPVARIANT(&pv);
 };
+#endif
 
 // @pymethod <o PyIPropertyStore>|propsys|PSCreateMemoryPropertyStore|Creates a temporary property store that is not connected to any backing storage
 // @comm May also be used to create <o PyINamedPropertyStore>, <o PyIPropertyStoreCache>, <o PyIPersistStream>, or <o PyIPropertyBag>
@@ -566,8 +568,10 @@ static struct PyMethodDef propsys_methods[]=
 	{ "PSRegisterPropertySchema", PyPSRegisterPropertySchema, 1 }, // @pymeth PSRegisterPropertySchema|Registers a group of properties described in a schema file
 	{ "PSUnregisterPropertySchema", PyPSUnregisterPropertySchema, 1 }, // @pymeth PSUnregisterPropertySchema|Removes a property schema definition
 	{ "SHGetPropertyStoreFromParsingName", PySHGetPropertyStoreFromParsingName, 1 }, // @pymeth SHGetPropertyStoreFromParsingName|Retrieves the property store for an item by path
+#if !defined(__MINGW32__)
 	{ "StgSerializePropVariant", PyStgSerializePropVariant, 1 }, // @pymeth StgSerializePropVariant|Serializes a <o PyPROPVARIANT>
 	{ "StgDeserializePropVariant", PyStgDeserializePropVariant, 1 }, // @pymeth StgDeserializePropVariant|Creates a <o PyPROPVARIANT> from a serialized buffer
+#endif
 	{ "PSCreateMemoryPropertyStore", PyPSCreateMemoryPropertyStore, 1 }, // @pymeth PSCreateMemoryPropertyStore|Creates a temporary property store that is not connected to any backing storage
 	{ "PSCreatePropertyStoreFromPropertySetStorage", PyPSCreatePropertyStoreFromPropertySetStorage, 1 }, // @pymeth PSCreatePropertyStoreFromPropertySetStorage|Wraps a <o PyIPropertySetStorage> interface in a <o PyIPropertyStore> object
 	{ "PSLookupPropertyHandlerCLSID", PyPSLookupPropertyHandlerCLSID, 1 }, // @pymeth PSLookupPropertyHandlerCLSID|Returns the GUID of the property handler for a file
@@ -583,7 +587,7 @@ static struct PyMethodDef propsys_methods[]=
 	// MSDN says CLSID_PropertyChangeArray can be used to create IPropertyChangeArray, but
 	// I get "Class not registered".  Plus, it doesn't appear in any headers, although
 	// it's contained in uuid.lib.
-#ifndef CLSID_PropertyChangeArray
+#if !defined(CLSID_PropertyChangeArray) && !defined(__MINGW32__)
 	EXTERN_C const CLSID CLSID_PropertyChangeArray;
 #endif
 
@@ -606,7 +610,9 @@ static const PyCom_InterfaceSupportInfo g_interfaceSupportData[] =
 	PYCOM_INTERFACE_CLIENT_ONLY (ObjectWithPropertyKey),
 	PYCOM_INTERFACE_CLIENT_ONLY (PropertyChange),
 	PYCOM_INTERFACE_CLIENT_ONLY (PropertyChangeArray),
+#if !defined(__MINGW32__)
 	PYCOM_INTERFACE_CLSID_ONLY (PropertyChangeArray),
+#endif
 };
 
 /* Module initialisation */
diff --git a/com/win32comext/shell/src/PyICategoryProvider.cpp b/com/win32comext/shell/src/PyICategoryProvider.cpp
index e2f2ea8..0ecf0cf 100644
--- a/com/win32comext/shell/src/PyICategoryProvider.cpp
+++ b/com/win32comext/shell/src/PyICategoryProvider.cpp
@@ -9,6 +9,10 @@
 //
 // Interface Implementation
 
+#if defined(__MINGW32__)
+__CRT_UUID_DECL(int, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
+#endif
+
 PyICategoryProvider::PyICategoryProvider(IUnknown *pdisp):
 	PyIUnknown(pdisp)
 {
diff --git a/com/win32comext/shell/src/initguid.cpp b/com/win32comext/shell/src/initguid.cpp
new file mode 100644
index 0000000..8da5c87
--- /dev/null
+++ b/com/win32comext/shell/src/initguid.cpp
@@ -0,0 +1,11 @@
+#define INITGUID
+#undef _OBJIDLBASE_
+#define CINTERFACE
+#define USE_COM_CONTEXT_DEF
+#include <objidl.h>
+#include <ksguid.h>
+#include <ks.h>
+#include <shlguid.h>
+#include <shobjidl.h>
+#include <emptyvc.h>
+#include <_mingw.h>
diff --git a/com/win32comext/shell/src/shell.cpp b/com/win32comext/shell/src/shell.cpp
index 8b6e78c..f19a021 100644
--- a/com/win32comext/shell/src/shell.cpp
+++ b/com/win32comext/shell/src/shell.cpp
@@ -29,8 +29,10 @@ generates Windows .hlp files.
 #include "PyIShellExtInit.h"
 #include "PyIShellFolder.h"
 #include "PyIShellFolder2.h"
+#if !defined(__MINGW32__)
 #include "PyIEmptyVolumeCache.h"
 #include "PyIEmptyVolumeCacheCallBack.h"
+#endif
 #include "PyIEnumExplorerCommand.h"
 #include "PyIEnumIDList.h"
 #include "PyICopyHook.h"
@@ -3606,12 +3608,16 @@ static const PyCom_InterfaceSupportInfo g_interfaceSupportData[] =
 	PYCOM_INTERFACE_FULL(ColumnProvider),
 	PYCOM_INTERFACE_CLIENT_ONLY(DefaultExtractIconInit),
 	PYCOM_INTERFACE_FULL(DropTargetHelper),
+#if !defined(__MINGW32__)
 	PYCOM_INTERFACE_CLIENT_ONLY(EmptyVolumeCacheCallBack),
+#endif
 	PYCOM_INTERFACE_CLIENT_ONLY(QueryAssociations),
 	PYCOM_INTERFACE_SERVER_ONLY(DeskBand),
 	PYCOM_INTERFACE_SERVER_ONLY(DockingWindow),
+#if !defined(__MINGW32__)
 	PYCOM_INTERFACE_SERVER_ONLY(EmptyVolumeCache),
 	PYCOM_INTERFACE_SERVER_ONLY(EmptyVolumeCache2),
+#endif
 	PYCOM_INTERFACE_CLIENT_ONLY(ExplorerBrowser),
 	PYCOM_INTERFACE_FULL(ExplorerBrowserEvents),
 	PYCOM_INTERFACE_FULL(ExplorerCommand),
@@ -3850,12 +3856,16 @@ PYWIN_MODULE_INIT_FUNC(shell)
 	ADD_IID(FMTID_Briefcase);
 	ADD_IID(FMTID_Misc);
 	ADD_IID(FMTID_WebView);
+#if !defined(__MINGW32__)
 	ADD_IID(FMTID_AudioSummaryInformation);
+#endif
 	ADD_IID(FMTID_Volume);
 	ADD_IID(FMTID_Query);
+#if !defined(__MINGW32__)
 	ADD_IID(FMTID_SummaryInformation);
 	ADD_IID(FMTID_MediaFileSummaryInformation);
 	ADD_IID(FMTID_ImageSummaryInformation);
+#endif
 	ADD_IID(IID_CDefView);
 
 	ADD_IID(EP_NavPane);
diff --git a/com/win32comext/taskscheduler/src/initguid.cpp b/com/win32comext/taskscheduler/src/initguid.cpp
new file mode 100644
index 0000000..d588502
--- /dev/null
+++ b/com/win32comext/taskscheduler/src/initguid.cpp
@@ -0,0 +1,8 @@
+#define INITGUID
+#undef _OBJIDLBASE_
+#define CINTERFACE
+#define USE_COM_CONTEXT_DEF
+#include <objidl.h>
+#include <ksguid.h>
+#include <ks.h>
+#include <mstask.h>
diff --git a/isapi/src/Utils.cpp b/isapi/src/Utils.cpp
index 8f278f2..b8976ae 100644
--- a/isapi/src/Utils.cpp
+++ b/isapi/src/Utils.cpp
@@ -127,7 +127,11 @@ static void CheckRegisterEventSourceFile()
 		return;
 
 	GetModuleFileNameW(g_hInstance, mod_name,
+#if defined(__MINGW32__)
+			  sizeof(mod_name)/sizeof(WCHAR));
+#else
 			  sizeof mod_name/sizeof WCHAR);
+#endif
 	if (!mod_name[0]) {
 		OutputDebugString(_T("GetModuleFileNameW failed!"));
 		return;
@@ -160,6 +164,9 @@ static void CheckRegisterEventSourceFile()
 }
 
 // Write stuff to the event log.
+#if defined(__MINGW32__)
+extern "C"
+#endif
 BOOL WriteEventLogMessage(WORD eventType, DWORD eventID, WORD num_inserts,
                           const char **inserts)
 {
diff --git a/isapi/src/Utils.h b/isapi/src/Utils.h
index 3779ca9..f076826 100644
--- a/isapi/src/Utils.h
+++ b/isapi/src/Utils.h
@@ -58,6 +58,9 @@ char *HTMLErrorResp(const char *msg);
 TCHAR *GetModulePath(void);
 
 // Write entry to the event log
+#if defined(__MINGW32__)
+extern "C"
+#endif
 BOOL WriteEventLogMessage(WORD eventType, DWORD eventID, WORD num_inserts,
                           const char **inserts);
 
diff --git a/isapi/src/pyISAPI.cpp b/isapi/src/pyISAPI.cpp
index 439d3ca..2c94610 100644
--- a/isapi/src/pyISAPI.cpp
+++ b/isapi/src/pyISAPI.cpp
@@ -52,6 +52,9 @@ char g_CallbackModuleName[_MAX_PATH + _MAX_FNAME] = "";
 #define TRACE(x) OutputDebugString(_T(x))
 
 // This is an entry point for py2exe.
+#if defined(__MINGW32__)
+extern "C"
+#endif
 void WINAPI PyISAPISetOptions(const char *modname, BOOL is_frozen)
 {
 	strncpy(g_CallbackModuleName, modname,
diff --git a/setup.py b/setup.py
index 7c35d90..5872968 100644
--- a/setup.py
+++ b/setup.py
@@ -72,6 +72,8 @@ import shutil
 
 is_py3k = sys.version_info > (3,) # get this out of the way early on...
 
+build_mingw32=True
+
 try:
     import winreg # py3k
 except ImportError:
@@ -140,6 +142,10 @@ dll_base_address = 0x1e200000
 def find_platform_sdk_dir():
     # The user might have their current environment setup for the
     # SDK, in which case "MSSDK_INCLUDE" and "MSSDK_LIB" vars must be set.
+    if build_mingw32:
+        return { "include": ["c:/msys64/mingw32/include", "c:/msys64/mingw32/i686-w64-mingw32/include"], 
+	         "lib": ["c:/msys64/mingw32/lib", "c:/msys64//mingw32/i686-w64-mingw32/lib"] }
+
     if "MSSDK_INCLUDE" in os.environ and "MSSDK_LIB" in os.environ:
         print("Using SDK as specified in the environment")
         return {
@@ -173,9 +179,10 @@ def find_platform_sdk_dir():
 # to prevent the extension from loading.  For more details, see
 # http://bugs.python.org/issue7833 (which has landed for Python 2.7 and on 3.2
 # and later, which are all we care about currently)
-from distutils.msvc9compiler import MSVCCompiler
-MSVCCompiler._orig_spawn = MSVCCompiler.spawn
-MSVCCompiler._orig_link = MSVCCompiler.link
+if not build_mingw32:
+    from distutils.msvc9compiler import MSVCCompiler
+    MSVCCompiler._orig_spawn = MSVCCompiler.spawn
+    MSVCCompiler._orig_link = MSVCCompiler.link
 
 # We need to override this method for versions where issue7833 *has* landed
 # (ie, 2.7 and 3.2+)
@@ -195,7 +202,8 @@ def manifest_get_embed_info(self, target_desc, ld_args):
 
 # always monkeypatch it in even though it will only be called in 2.7
 # and 3.2+.
-MSVCCompiler.manifest_get_embed_info = manifest_get_embed_info
+if not build_mingw32:
+    MSVCCompiler.manifest_get_embed_info = manifest_get_embed_info
 
 def monkeypatched_spawn(self, cmd):
     is_link = cmd[0].endswith("link.exe") or cmd[0].endswith('"link.exe"')
@@ -239,8 +247,9 @@ def monkeypatched_link(self, target_desc, objects, output_filename, *args, **kw)
         return self._orig_link(target_desc, objects, output_filename, *args, **kw)
     finally:
         delattr(self, '_want_assembly_kept')
-MSVCCompiler.spawn = monkeypatched_spawn
-MSVCCompiler.link = monkeypatched_link
+if not build_mingw32:
+    MSVCCompiler.spawn = monkeypatched_spawn
+    MSVCCompiler.link = monkeypatched_link
 
 
 sdk_info = find_platform_sdk_dir()
@@ -449,6 +458,18 @@ class WinExt (Extension):
                 # Unicode, Windows executables seem to need this magic:
                 if "/SUBSYSTEM:WINDOWS" in self.extra_link_args:
                     self.extra_link_args.append("/ENTRY:wWinMainCRTStartup")
+        else:
+            self.extra_compile_args.append("-fpermissive")
+            unicode_mode = self.unicode_mode
+            if unicode_mode is None:
+                unicode_mode = is_py3k
+            if unicode_mode:
+                self.extra_compile_args.append("-DUNICODE")
+                self.extra_compile_args.append("-D_UNICODE")
+                self.extra_compile_args.append("-DWINNT")
+                # Unicode, Windows executables seem to need this magic:
+                #if "/SUBSYSTEM:WINDOWS" in self.extra_link_args:
+                #    self.extra_link_args.append("/ENTRY:wWinMainCRTStartup")
 
 class WinExt_pythonwin(WinExt):
     def __init__ (self, name, **kw):
@@ -641,7 +662,7 @@ class my_build_ext(build_ext):
         # The pywintypes library is created in the build_temp
         # directory, so we need to add this to library_dirs
         self.library_dirs.append(self.build_temp)
-        self.mingw32 = (self.compiler == "mingw32")
+        self.mingw32 = build_mingw32
         if self.mingw32:
             self.libraries.append("stdc++")
 
@@ -698,7 +719,8 @@ class my_build_ext(build_ext):
             self.compiler.add_include_dir(extra)
         # and again for lib dirs.
         for extra in sdk_info["lib"]:
-            extra = os.path.join(extra, 'x64' if is_64bit else 'x86')
+            if not build_mingw32:
+                extra = os.path.join(extra, 'x64' if is_64bit else 'x86')
             assert os.path.isdir(extra), extra
             assert extra not in self.library_dirs # see above
             assert os.path.isdir(extra), "%s doesn't exist!" % (extra,)
@@ -714,7 +736,7 @@ class my_build_ext(build_ext):
         # includes interfaces for 64-bit builds.
         if self.plat_name == 'win-amd64' and ext.name == 'exchdapi':
             return "No 64-bit library for utility functions available."
-        if get_build_version() >=14:
+        if not build_mingw32 and get_build_version() >=14:
             if ext.name == 'exchange':
                 ext.libraries.append('legacy_stdio_definitions')
             elif ext.name == 'exchdapi':
@@ -758,7 +780,8 @@ class my_build_ext(build_ext):
 
         # We update the .libraries list with the resolved library name.
         # This is really only so "_d" works.
-        ext.libraries = patched_libs
+        if not build_mingw32:
+            ext.libraries = patched_libs
         return None # no reason - it can be built!
 
     def _build_scintilla(self):
@@ -972,11 +995,16 @@ class my_build_ext(build_ext):
         if sys.version_info > (2, 7) and sys.version_info < (3, 3):
             # only stuff built with msvc9 needs this loader.
             self._build_pycom_loader()
-        self._build_scintilla()
+        if not build_mingw32:
+            self._build_scintilla()
         # Copy cpp lib files needed to create Python COM extensions
-        clib_files = (['win32', 'pywintypes%s.lib'],
-                      ['win32com', 'pythoncom%s.lib'],
-                      ['win32com', 'axscript%s.lib'])
+        if build_mingw32:
+            clib_files = (['win32', 'libpywintypes%s.a'],
+                          ['win32com', 'libpythoncom%s.a'])
+        else:
+            clib_files = (['win32', 'pywintypes%s.lib'],
+                          ['win32com', 'pythoncom%s.lib'],
+                          ['win32com', 'axscript%s.lib'])
         for clib_file in clib_files:
             target_dir = os.path.join(self.build_lib, clib_file[0], "libs")
             if not os.path.exists(target_dir):
@@ -988,6 +1016,8 @@ class my_build_ext(build_ext):
             self.copy_file(os.path.join(self.build_temp, fname),
                            target_dir
                            )
+        if build_mingw32:
+            return
         # The MFC DLLs.
         target_dir = os.path.join(self.build_lib, "pythonwin")
 
@@ -1081,9 +1111,13 @@ class my_build_ext(build_ext):
         # this, distutils gets confused, as they both try and use the same
         # .obj.
         output_dir = os.path.join(self.build_temp, ext.name)
+        if build_mingw32:
+            include_dirs = [output_dir, os.path.join(output_dir, "win32", "src")] + ext.include_dirs
+        else:
+            include_dirs = ext.include_dirs
         kw = {'output_dir': output_dir,
               'macros': macros,
-              'include_dirs': ext.include_dirs,
+              'include_dirs': include_dirs,
               'debug': self.debug,
               'extra_postargs': extra_args,
               'depends': ext.depends,
@@ -1115,6 +1149,7 @@ class my_build_ext(build_ext):
                'extra_postargs': extra_args,
                'debug': self.debug,
                'build_temp': self.build_temp,
+               'extra_preargs': []
         }
 
         # Detect target language, if not provided
@@ -1162,22 +1197,37 @@ class my_build_ext(build_ext):
         old_build_temp = self.build_temp
         want_static_crt = sys.version_info > (2,6) and ext.name in static_crt_modules
         if want_static_crt:
-            self.compiler.compile_options.remove('/MD')
-            self.compiler.compile_options.append('/MT')
-            self.compiler.compile_options_debug.remove('/MDd')
-            self.compiler.compile_options_debug.append('/MTd')
+            if not build_mingw32:
+                self.compiler.compile_options.remove('/MD')
+                self.compiler.compile_options.append('/MT')
+                self.compiler.compile_options_debug.remove('/MDd')
+                self.compiler.compile_options_debug.append('/MTd')
 
         try:
+            if build_mingw32:
+                incs = set()
+                for source in ext.sources:
+                    output_dir = os.path.join(self.build_temp, os.path.dirname(source))
+                    if output_dir not in incs:
+                        ext.include_dirs.append(output_dir)
+                        incs.add(output_dir)
             build_ext.build_extension(self, ext)
             # XXX This has to be changed for mingw32
             # Get the .lib files we need.  This is limited to pywintypes,
             # pythoncom and win32ui - but the first 2 have special names
-            extra = self.debug and "_d.lib" or ".lib"
+            if build_mingw32:
+                extra = self.debug and "_d.a" or ".a"
+            else:
+                extra = self.debug and "_d.lib" or ".lib"
             if ext.name in ("pywintypes", "pythoncom"):
                 # The import libraries are created as PyWinTypes23.lib, but
                 # are expected to be pywintypes.lib.
-                name1 = "%s%d%d%s" % (ext.name, sys.version_info[0], sys.version_info[1], extra)
-                name2 = "%s%s" % (ext.name, extra)
+                if build_mingw32:
+                    name1 = "lib%s%d%d%s" % (ext.name, sys.version_info[0], sys.version_info[1], extra)
+                    name2 = "lib%s%s" % (ext.name, extra)
+                else:
+                    name1 = "%s%d%d%s" % (ext.name, sys.version_info[0], sys.version_info[1], extra)
+                    name2 = "%s%s" % (ext.name, extra)
             elif ext.name in ("win32ui",):
                 name1 = name2 = ext.name + extra
             else:
@@ -1199,10 +1249,11 @@ class my_build_ext(build_ext):
         finally:
             self.build_temp = old_build_temp
             if want_static_crt:
-                self.compiler.compile_options.remove('/MT')
-                self.compiler.compile_options.append('/MD')
-                self.compiler.compile_options_debug.remove('/MTd')
-                self.compiler.compile_options_debug.append('/MDd')
+                if not build_mingw32:
+                    self.compiler.compile_options.remove('/MT')
+                    self.compiler.compile_options.append('/MD')
+                    self.compiler.compile_options_debug.remove('/MTd')
+                    self.compiler.compile_options_debug.append('/MDd')
 
     def get_ext_filename(self, name):
         # The pywintypes and pythoncom extensions have special names
@@ -1298,6 +1349,8 @@ class my_build_ext(build_ext):
         for source in swig_sources:
             swig_cmd = [swig, "-python", "-c++"]
             swig_cmd.append("-dnone",) # we never use the .doc files.
+            if not build_mingw32:
+                swig_cmd.append("-I" + os.path.abspath("swig/swig_lib/python"))
             swig_cmd.extend(self.current_extension.extra_swig_commands)
             if not is_py3k:
                 swig_cmd.append("-DSWIG_PY2K")
@@ -1368,7 +1421,10 @@ class my_install(install):
         if not self.dry_run and not self.root:
             # We must run the script we just installed into Scripts, as it
             # may have had 2to3 run over it.
-            filename = os.path.join(self.prefix, "Scripts", "pywin32_postinstall.py")
+            if build_mingw32:
+                filename = os.path.join(self.prefix, "bin", "pywin32_postinstall.py")
+            else:
+                filename = os.path.join(self.prefix, "Scripts", "pywin32_postinstall.py")
             if not os.path.isfile(filename):
                 raise RuntimeError("Can't find '%s'" % (filename,))
             print("Executing post install script...")
@@ -1388,18 +1444,25 @@ def my_new_compiler(**kw):
     return orig_new_compiler(**kw)
 
 # No way to cleanly wedge our compiler sub-class in.
-from distutils import ccompiler, msvccompiler
+from distutils import ccompiler
 orig_new_compiler = ccompiler.new_compiler
 ccompiler.new_compiler = my_new_compiler
 
-base_compiler = msvccompiler.MSVCCompiler
+if build_mingw32:
+    from distutils import cygwinccompiler
+    base_compiler = cygwinccompiler.Mingw32CCompiler
+else:
+    from distutils import msvccompiler
+    base_compiler = msvccompiler.MSVCCompiler
+
 
 class my_compiler(base_compiler):
     # Just one GUIDS.CPP and it gives trouble on mainwin too. Maybe I
     # should just rename the file, but a case-only rename is likely to be
     # worse!  This can probably go away once we kill the VS project files
     # though, as we can just specify the lowercase name in the module def.
-    _cpp_extensions = base_compiler._cpp_extensions + [".CPP"]
+    if not build_mingw32:
+        _cpp_extensions = base_compiler._cpp_extensions + [".CPP"]
     src_extensions = base_compiler.src_extensions + [".CPP"]
 
     def link(self,
@@ -1411,17 +1474,41 @@ class my_compiler(base_compiler):
               library_dirs=None,
               runtime_library_dirs=None,
               export_symbols=None,
-              debug=0, *args, **kw):
-        msvccompiler.MSVCCompiler.link( self,
-                                        target_desc,
-                                        objects,
-                                        output_filename,
-                                        output_dir,
-                                        libraries,
-                                        library_dirs,
-                                        runtime_library_dirs,
-                                        export_symbols,
-                                        debug, *args, **kw)
+              debug=0, extra_preargs = None, *args, **kw):
+        if build_mingw32:
+            temp_dir = os.path.dirname(objects[0])
+            dll_name = os.path.splitext(os.path.basename(output_filename))[0]
+            lib_file = os.path.join(temp_dir, 'lib' + dll_name + ".a")
+            implib_arg="-Wl,--out-implib,%s" % lib_file
+
+            if extra_preargs:
+                extra_preargs.extend(implib_arg)
+            else:
+                extra_preargs = [implib_arg]
+
+            cygwinccompiler.Mingw32CCompiler.link( self,
+                                                   target_desc,
+                                                   objects,
+                                                   output_filename,
+                                                   output_dir,
+                                                   libraries,
+                                                   library_dirs,
+                                                   runtime_library_dirs,
+                                                   export_symbols,
+                                                   debug, extra_preargs,
+                                                   *args, **kw)
+        else:
+            msvccompiler.MSVCCompiler.link( self,
+                                            target_desc,
+                                            objects,
+                                            output_filename,
+                                            output_dir,
+                                            libraries,
+                                            library_dirs,
+                                            runtime_library_dirs,
+                                            export_symbols,
+                                            debug, *args, **kw)
+
         # Here seems a good place to stamp the version of the built
         # target.  Do this externally to avoid suddenly dragging in the
         # modules needed by this process, and which we will soon try and
@@ -1457,6 +1544,45 @@ class my_compiler(base_compiler):
         if not ok:
             log.info('Unable to import verstamp, no version info will be added')
 
+    if build_mingw32:
+        def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):
+            if ext == ".mc":
+                try:
+                    basename=os.path.basename(src)[:-3]
+                    outdir=os.path.dirname(obj)
+                    self.spawn(["windmc", "-h", outdir, "-r", outdir, src])
+                    self.spawn(["windres", "-i", 
+                                os.path.join(outdir, basename + ".rc"),
+                                "-o", obj])
+                except DistutilsExecError as msg:
+                    raise CompileError(msg)
+            else:
+                cygwinccompiler.Mingw32CCompiler._compile(self,
+                                                          obj, src, ext, cc_args,
+                                                          extra_postargs, pp_opts)
+
+        def object_filenames(self, source_filenames, strip_dir=0, output_dir=''):
+            unproc_src_names = []
+            obj_names = []
+            for src_name in source_filenames:
+                base, ext = os.path.splitext(src_name)
+                if ext==".mc":
+                    if unproc_src_names:
+                        obj_names.extend(cygwinccompiler.Mingw32CCompiler.\
+                            object_filenames(self, unproc_src_names,
+                                             strip_dir = strip_dir,
+                                             output_dir = output_dir))
+                        unproc_src_names = []
+                    obj_names.append (os.path.join(output_dir,
+                                      base + ext + self.obj_extension))
+                else:
+                    unproc_src_names.append(src_name)
+            if unproc_src_names:
+                obj_names.extend(cygwinccompiler.Mingw32CCompiler.\
+                    object_filenames(self, unproc_src_names, strip_dir = strip_dir,
+                                     output_dir = output_dir))
+            return obj_names
+
 
 ################################################################
 
@@ -1550,7 +1676,7 @@ for info in (
             win32/src/win32crypt/PyCRYPTPROV.cpp
             win32/src/win32crypt/PyCTL_CONTEXT.cpp
             """),
-        ("win32file", "", None, 0x0500, """
+        ("win32file", "wsock32 ws2_32" if build_mingw32 else "", None, 0x0500, """
               win32/src/win32file.i
               win32/src/win32file_comm.cpp
               """),
@@ -1607,7 +1733,7 @@ for info in (
         sources = info[4].split()
     extra_compile_args = []
     ext = WinExt_win32(name,
-                 libraries=lib_names,
+                 libraries=lib_names + (" pywintypes" if build_mingw32 else ""),
                  extra_compile_args = extra_compile_args,
                  windows_h_version = windows_h_ver,
                  sources = sources,
@@ -1620,7 +1746,7 @@ win32_extensions += [
             sources = """
                 win32\\src\\win32evtlog_messages.mc win32\\src\\win32evtlog.i
                 """.split(),
-                libraries="advapi32 oleaut32",
+                libraries="advapi32 oleaut32" + (" pywintypes" if build_mingw32 else ""),
                 delay_load_libraries="wevtapi",
                 windows_h_version=0x0600
         ),
@@ -1628,7 +1754,7 @@ win32_extensions += [
            sources = """
                 win32/src/win32apimodule.cpp win32/src/win32api_display.cpp
                 """.split(),
-           libraries="user32 advapi32 shell32 version",
+                 libraries="user32 advapi32 shell32 version" + (" pywintypes" if build_mingw32 else ""),
            delay_load_libraries="powrprof",
            windows_h_version=0x0500,
         ),
@@ -1638,7 +1764,7 @@ win32_extensions += [
                 win32/src/win32gui.i
                """.split(),
            windows_h_version=0x0500,
-           libraries="gdi32 user32 comdlg32 comctl32 shell32",
+           libraries="gdi32 user32 comdlg32 comctl32 shell32" + (" pywintypes" if build_mingw32 else ""),
            define_macros = [("WIN32GUI", None)],
         ),
     # winxpgui is built from win32gui.i, but sets up different #defines before
@@ -1648,7 +1774,7 @@ win32_extensions += [
                 win32/src/winxpgui.rc win32/src/win32dynamicdialog.cpp
                 win32/src/win32gui.i
                """.split(),
-           libraries="gdi32 user32 comdlg32 comctl32 shell32",
+           libraries="gdi32 user32 comdlg32 comctl32 shell32" + (" pywintypes" if build_mingw32 else ""),
            windows_h_version=0x0500,
            define_macros = [("WIN32GUI",None), ("WINXPGUI",None)],
            extra_swig_commands=["-DWINXPGUI"],
@@ -1656,7 +1782,7 @@ win32_extensions += [
     # winxptheme
     WinExt_win32("_winxptheme",
            sources = ["win32/src/_winxptheme.i"],
-           libraries="gdi32 user32 comdlg32 comctl32 shell32 Uxtheme",
+           libraries="gdi32 user32 comdlg32 comctl32 shell32 Uxtheme" + (" pywintypes" if build_mingw32 else ""),
            windows_h_version=0x0500,
         ),
 ]
@@ -1664,7 +1790,7 @@ win32_extensions += [
     WinExt_win32('servicemanager',
            sources = ["win32/src/PythonServiceMessages.mc", "win32/src/PythonService.cpp"],
            extra_compile_args = ['-DPYSERVICE_BUILD_DLL'],
-           libraries = "user32 ole32 advapi32 shell32",
+           libraries = "user32 ole32 advapi32 shell32" + (" pywintypes" if build_mingw32 else ""),
            windows_h_version = 0x500,
            unicode_mode=True,),
 ]
@@ -1695,7 +1821,8 @@ dirs = {
 
 # The COM modules.
 pythoncom = WinExt_system32('pythoncom',
-                   sources=("""
+                   sources=((("%(win32com)s/initguid.cpp"  if build_mingw32 else "") +
+                        """
                         %(win32com)s/dllmain.cpp            %(win32com)s/ErrorUtils.cpp
                         %(win32com)s/MiscTypes.cpp          %(win32com)s/oleargs.cpp
                         %(win32com)s/PyComHelpers.cpp       %(win32com)s/PyFactory.cpp
@@ -1737,7 +1864,7 @@ pythoncom = WinExt_system32('pythoncom',
                         %(win32com)s/extensions/PyICancelMethodCalls.cpp    %(win32com)s/extensions/PyIContext.cpp
                         %(win32com)s/extensions/PyIEnumContextProps.cpp     %(win32com)s/extensions/PyIClientSecurity.cpp
                         %(win32com)s/extensions/PyIServerSecurity.cpp
-                        """ % dirs).split(),
+                        """) % dirs).split(),
                    depends=("""
                         %(win32com)s/include\\propbag.h          %(win32com)s/include\\PyComTypeObjects.h
                         %(win32com)s/include\\PyFactory.h        %(win32com)s/include\\PyGConnectionPoint.h
@@ -1763,7 +1890,7 @@ pythoncom = WinExt_system32('pythoncom',
                         %(win32com)s/include\\PyIEnumContextProps.h     %(win32com)s/include\\PyIClientSecurity.h
                         %(win32com)s/include\\PyIServerSecurity.h
                         """ % dirs).split(),
-                   libraries = "oleaut32 ole32 user32 urlmon",
+                   libraries = "oleaut32 ole32 user32 urlmon uuid" + (" pywintypes" if build_mingw32 else ""),
                    export_symbol_file = 'com/win32com/src/PythonCOM.def',
                    extra_compile_args = ['-DBUILD_PYTHONCOM'],
                    pch_header = "stdafx.h",
@@ -1788,7 +1915,7 @@ com_extensions += [
                         %(adsi)s/PyIADs.cpp
                         """ % dirs).split()),
     WinExt_win32com('axcontrol', pch_header="axcontrol_pch.h",
-                    sources=("""
+                    sources=(("""
                         %(axcontrol)s/AXControl.cpp
                         %(axcontrol)s/PyIOleControl.cpp          %(axcontrol)s/PyIOleControlSite.cpp
                         %(axcontrol)s/PyIOleInPlaceActiveObject.cpp
@@ -1799,10 +1926,11 @@ com_extensions += [
                         %(axcontrol)s/PyIOleClientSite.cpp       %(axcontrol)s/PyIOleInPlaceSite.cpp
                         %(axcontrol)s/PyIOleObject.cpp           %(axcontrol)s/PyIViewObject2.cpp
                         %(axcontrol)s/PyIOleCommandTarget.cpp
-                        """ % dirs).split()),
+                        """ + ("%(axcontrol)s/initguid.cpp" if build_mingw32 else "")) % dirs).split(),
+                        libraries="pythoncom pywintypes"),
     WinExt_win32com('axscript',
-                    sources=("""
-                        %(axscript)s/AXScript.cpp
+                    sources=(("""
+                        %(axscript)s/AXScript.cpp                %(axscript)s/initguid.cpp
                         %(axscript)s/GUIDS.CPP                   %(axscript)s/PyGActiveScript.cpp
                         %(axscript)s/PyGActiveScriptError.cpp    %(axscript)s/PyGActiveScriptParse.cpp
                         %(axscript)s/PyGActiveScriptSite.cpp     %(axscript)s/PyGObjectSafety.cpp
@@ -1810,7 +1938,7 @@ com_extensions += [
                         %(axscript)s/PyIActiveScriptParse.cpp    %(axscript)s/PyIActiveScriptParseProcedure.cpp
                         %(axscript)s/PyIActiveScriptSite.cpp     %(axscript)s/PyIMultiInfos.cpp
                         %(axscript)s/PyIObjectSafety.cpp         %(axscript)s/stdafx.cpp
-                        """ % dirs).split(),
+                        """ + ("%(axscript)s/initguid.cpp" if build_mingw32 else "")) % dirs).split(),
                     depends=("""
                              %(axscript)s/AXScript.h
                              %(axscript)s/guids.h                %(axscript)s/PyGActiveScriptError.h
@@ -1820,7 +1948,8 @@ com_extensions += [
                              """ % dirs).split(),
                     extra_compile_args = ['-DPY_BUILD_AXSCRIPT'],
                     implib_name="axscript",
-                    pch_header = "stdafx.h"
+                    pch_header = "stdafx.h",
+                    libraries="pythoncom pywintypes" if build_mingw32 else ""
     ),
     WinExt_win32com('axdebug',
             libraries="axscript",
@@ -1870,17 +1999,17 @@ com_extensions += [
                     %(axdebug)s/PyIRemoteDebugApplicationEvents.cpp
                     %(axdebug)s/PyIRemoteDebugApplicationThread.cpp
                     %(axdebug)s/stdafx.cpp
-                     """ % dirs).split(),
-    ),
+                     """ % dirs).split() ),
     WinExt_win32com('internet', pch_header="internet_pch.h",
-                    sources=("""
+                    sources=(("""
                         %(internet)s/internet.cpp                   %(internet)s/PyIDocHostUIHandler.cpp
                         %(internet)s/PyIHTMLOMWindowServices.cpp    %(internet)s/PyIInternetBindInfo.cpp
                         %(internet)s/PyIInternetPriority.cpp        %(internet)s/PyIInternetProtocol.cpp
                         %(internet)s/PyIInternetProtocolInfo.cpp    %(internet)s/PyIInternetProtocolRoot.cpp
                         %(internet)s/PyIInternetProtocolSink.cpp    %(internet)s/PyIInternetSecurityManager.cpp
-                    """ % dirs).split(),
-                    depends=["%(internet)s/internet_pch.h" % dirs]),
+                    """ + ("%(internet)s/initguid.cpp"  if build_mingw32 else "")) % dirs).split(),
+                    depends=["%(internet)s/internet_pch.h" % dirs],
+                    libraries="pythoncom pywintypes" if build_mingw32 else ""),
     WinExt_win32com('mapi', libraries="advapi32", pch_header="PythonCOM.h",
                     include_dirs=["%(mapi)s/mapi_headers" % dirs],
                     optional_headers=['edkmdb.h', 'edkguid.h'],
@@ -1929,9 +2058,10 @@ com_extensions += [
                                   %(mapi)s/mapi_stub_library/MapiStubLibrary.cpp
                                   %(mapi)s/mapi_stub_library/StubUtils.cpp
                                   """ % dirs).split()),
-    WinExt_win32com('shell', libraries='shell32', pch_header="shell_pch.h",
+
+    WinExt_win32com('shell', libraries=('pythoncom pywintypes ' if build_mingw32 else '') + 'shell32', pch_header="shell_pch.h",
                     windows_h_version = 0x600,
-                    sources=("""
+                    sources=(("""
                         %(shell)s/PyIActiveDesktop.cpp
                         %(shell)s/PyIApplicationDestinations.cpp
                         %(shell)s/PyIApplicationDocumentLists.cpp
@@ -1956,8 +2086,6 @@ com_extensions += [
                         %(shell)s/PyIEnumObjects.cpp
                         %(shell)s/PyIEnumResources.cpp
                         %(shell)s/PyIEnumShellItems.cpp
-                        %(shell)s/PyIEmptyVolumeCache.cpp
-                        %(shell)s/PyIEmptyVolumeCacheCallBack.cpp
                         %(shell)s/PyIExplorerBrowser.cpp
                         %(shell)s/PyIExplorerBrowserEvents.cpp
                         %(shell)s/PyIExplorerCommand.cpp
@@ -2002,8 +2130,9 @@ com_extensions += [
                         %(shell)s/PyITransferSource.cpp
                         %(shell)s/PyIUniformResourceLocator.cpp
                         %(shell)s/shell.cpp
-
-                        """ % dirs).split()),
+                        """ + ("%(shell)s/initguid.cpp" if build_mingw32 else
+                               "%(shell)s/PyIEmptyVolumeCache.cpp %(shell)s/PyIEmptyVolumeCacheCallBack.cpp"))
+                             % dirs).split()),
 
     WinExt_win32com('propsys', libraries='propsys', delay_load_libraries='shell32',
                     unicode_mode=True,
@@ -2031,9 +2160,8 @@ com_extensions += [
                     implib_name="pypropsys",
                     ),
 
-
-    WinExt_win32com('taskscheduler', libraries='mstask',
-                    sources=("""
+    WinExt_win32com('taskscheduler', libraries='mstask' + (' pythoncom pywintypes'  if build_mingw32 else ''),
+                    sources=(("""
                         %(taskscheduler)s/taskscheduler.cpp
                         %(taskscheduler)s/PyIProvideTaskPage.cpp
                         %(taskscheduler)s/PyIScheduledWorkItem.cpp
@@ -2041,7 +2169,7 @@ com_extensions += [
                         %(taskscheduler)s/PyITaskScheduler.cpp
                         %(taskscheduler)s/PyITaskTrigger.cpp
 
-                        """ % dirs).split()),
+                        """ + ("%(taskscheduler)s/initguid.cpp" if build_mingw32 else ""))% dirs).split()),
     WinExt_win32com('bits', libraries='Bits', pch_header="bits_pch.h",
                     sources=("""
                         %(bits)s/bits.cpp
@@ -2077,12 +2205,12 @@ com_extensions += [
                         %(directsound)s/PyIDirectSoundCaptureBuffer.h %(directsound)s/PyIDirectSoundNotify.h
                         """ % dirs).split(),
                     optional_headers = ['dsound.h'],
-                    libraries='user32 dsound dxguid'),
-    WinExt_win32com('authorization', libraries='aclui advapi32',
+                    libraries=('pythoncom pywintypes ' if build_mingw32 else '') + 'user32 dsound dxguid uuid'),
+    WinExt_win32com('authorization', libraries=('pythoncom pywintypes ' if build_mingw32 else '') + 'aclui advapi32',
                     sources=("""
                         %(authorization)s/authorization.cpp
                         %(authorization)s/PyGSecurityInformation.cpp
-                        """ % dirs).split()),
+                        """ % dirs).split())
 ]
 
 pythonwin_extensions = [
@@ -2253,20 +2381,24 @@ other_extensions.append(
 W32_exe_files = [
     WinExt_win32("pythonservice",
          sources=[os.path.join("win32", "src", s) for s in
-                  "PythonService.cpp PythonService.rc".split()],
+                  (("PythonServiceMessages.mc " if build_mingw32 else "") + "PythonService.cpp PythonService.rc").split()],
          unicode_mode = True,
-         extra_link_args=["/SUBSYSTEM:CONSOLE"],
-         libraries = "user32 advapi32 ole32 shell32"),
-    WinExt_pythonwin("Pythonwin",
-        sources = [
-            "Pythonwin/pythonwin.cpp",
-            "Pythonwin/pythonwin.rc",
-            "Pythonwin/stdafxpw.cpp",
-            ],
-        extra_link_args=["/SUBSYSTEM:WINDOWS"],
-        optional_headers=['afxres.h']),
+         extra_link_args=[] if build_mingw32 else ["/SUBSYSTEM:CONSOLE"],
+         libraries = ("pywintypes " if build_mingw32 else "") + "user32 advapi32 ole32 shell32")
 ]
 
+if not build_mingw32:
+    W32_exe_files.append(
+        WinExt_pythonwin("Pythonwin",
+            sources = [
+                "Pythonwin/pythonwin.cpp",
+                "Pythonwin/pythonwin.rc",
+                "Pythonwin/stdafxpw.cpp",
+            ],
+            extra_link_args=["/SUBSYSTEM:WINDOWS"],
+            optional_headers=['afxres.h'])
+        )
+
 # Special definitions for SWIG.
 swig_interface_parents = {
     # source file base,     "base class" for generated COM support
@@ -2415,7 +2547,10 @@ packages=['win32com',
           ]
 
 py_modules = expand_modules("win32\\lib")
-ext_modules = win32_extensions + com_extensions + pythonwin_extensions + \
+if build_mingw32:
+    ext_modules = win32_extensions + com_extensions + other_extensions
+else:
+    ext_modules = win32_extensions + com_extensions + pythonwin_extensions + \
                     other_extensions
 
 # Build a map of DLL base addresses.  According to Python's PC\dllbase_nt.txt,
diff --git a/win32/src/PerfMon/perfmondata.cpp b/win32/src/PerfMon/perfmondata.cpp
index 23e7557..c456d89 100644
--- a/win32/src/PerfMon/perfmondata.cpp
+++ b/win32/src/PerfMon/perfmondata.cpp
@@ -89,10 +89,19 @@ PPERF_COUNTER_BLOCK pCounterBlock;
 //      these are used to insure that the data collection functions
 //      accessed by Perflib will have the correct calling format.
 //
+
+#if defined(__MINGW32__)
+extern "C" {
+#endif
+
 PM_OPEN_PROC   OpenPerformanceData;
 PM_COLLECT_PROC    CollectPerformanceData;
 PM_CLOSE_PROC  ClosePerformanceData;
 
+#if defined(__MINGW32__)
+}
+#endif
+
 TCHAR szFullModulePath[MAX_PATH];
 TCHAR szModuleName[MAX_PATH]; // will point into the buffer above.
 
@@ -130,6 +139,9 @@ BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
 
 
 
+#if defined(__MINGW32__)
+extern "C"
+#endif
 DWORD APIENTRY OpenPerformanceData( LPWSTR lpDeviceNames )
 /*++
     Routine Description:
@@ -278,6 +290,9 @@ OpenExitPoint:
 	return status;
 }
 
+#if defined(__MINGW32__)
+extern "C"
+#endif
 DWORD APIENTRY CollectPerformanceData(
     IN      LPWSTR  lpValueName,
 	IN OUT  LPVOID  *lppData,
@@ -379,6 +394,9 @@ Arguments:   IN       LPWSTR   lpValueName
     return ERROR_SUCCESS;
 }
 
+#if defined(__MINGW32__)
+extern "C"
+#endif
 DWORD APIENTRY ClosePerformanceData()
 /*++
 Routine Description:
@@ -445,7 +463,11 @@ HANDLE MonOpenEventLog (const TCHAR *szSourceName)
 --*/
 {
     HKEY hAppKey;
+#if defined(__MINGW32__)
+    TCHAR LogLevelKeyName[] = _T("SOFTWARE\\Microsoft\\Windows_NT\\CurrentVersion\\Perflib");
+#else
     TCHAR LogLevelKeyName[] = _T("SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Perflib");
+#endif
 
     TCHAR LogLevelValueName[] = _T("EventLogLevel");
 	LONG lStatus;
diff --git a/win32/src/PySECURITY_DESCRIPTOR.cpp b/win32/src/PySECURITY_DESCRIPTOR.cpp
index 218daf9..2873603 100644
--- a/win32/src/PySECURITY_DESCRIPTOR.cpp
+++ b/win32/src/PySECURITY_DESCRIPTOR.cpp
@@ -6,6 +6,10 @@
 #include "PySecurityObjects.h"
 #include "structmember.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
+
 #ifndef NO_PYWINTYPES_SECURITY
 BOOL (WINAPI *setsecuritydescriptorcontrol)(PSECURITY_DESCRIPTOR, SECURITY_DESCRIPTOR_CONTROL, SECURITY_DESCRIPTOR_CONTROL)=NULL;
 
@@ -786,7 +790,11 @@ PySECURITY_DESCRIPTOR::PySECURITY_DESCRIPTOR(Py_ssize_t cb /*= 0*/)
 {
 	ob_type = &PySECURITY_DESCRIPTORType;
 	_Py_NewReference(this);
+#if defined(__MINGW32__)
+	cb = std::max(cb, static_cast<Py_ssize_t>(SECURITY_DESCRIPTOR_MIN_LENGTH));
+#else
 	cb = max(cb, SECURITY_DESCRIPTOR_MIN_LENGTH);
+#endif
 	PSECURITY_DESCRIPTOR psd = malloc(cb);
 	this->m_psd=NULL;
 	if (::InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION))
diff --git a/win32/src/PyWinTypes.h b/win32/src/PyWinTypes.h
index 00ac8a1..a5fc23e 100644
--- a/win32/src/PyWinTypes.h
+++ b/win32/src/PyWinTypes.h
@@ -393,8 +393,13 @@ PYWINTYPES_EXPORT PyObject *PyWinObject_FromULARGE_INTEGER(ULARGE_INTEGER &val);
 // We also happen to know a LARGE_INTEGER is an __int64, so do it the easy way
 #define PyWinObject_AsPY_LONG_LONG(ob, pResult) PyWinObject_AsLARGE_INTEGER((ob), (LARGE_INTEGER *)(pResult))
 #define PyWinObject_AsUPY_LONG_LONG(ob, pResult) PyWinObject_AsULARGE_INTEGER((ob), (ULARGE_INTEGER *)(pResult))
+#if defined(__MINGW32__)
+#define PyWinObject_FromPY_LONG_LONG(val) PyWinObject_FromLARGE_INTEGER(val)
+#define PyWinObject_FromUPY_LONG_LONG(val) PyWinObject_FromULARGE_INTEGER(val)
+#else
 #define PyWinObject_FromPY_LONG_LONG(val) PyWinObject_FromLARGE_INTEGER((LARGE_INTEGER)val)
 #define PyWinObject_FromUPY_LONG_LONG(val) PyWinObject_FromULARGE_INTEGER((ULARGE_INTEGER)val)
+#endif
 
 // A DWORD_PTR and ULONG_PTR appear to mean "integer long enough to hold a pointer"
 // It is *not* actually a pointer (but is the same size as a pointer)
@@ -797,7 +802,7 @@ private:
 
 // A helper for simple exception handling.
 // try/__try
-#ifdef MAINWIN
+#if defined(__MINGW32__) || defined(MAINWIN)
 #define PYWINTYPES_TRY try
 #else
 #define PYWINTYPES_TRY __try
diff --git a/win32/src/PyWinTypesmodule.cpp b/win32/src/PyWinTypesmodule.cpp
index e136fff..77e10a4 100644
--- a/win32/src/PyWinTypesmodule.cpp
+++ b/win32/src/PyWinTypesmodule.cpp
@@ -1140,7 +1140,11 @@ BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
 }
 
 // Function to format a python traceback into a character string.
+#if defined(__MINGW32__)
+#define GPEM_ERROR(what) {errorMsg = "<Error getting traceback - " what ">";goto done;}
+#else
 #define GPEM_ERROR(what) {errorMsg = "<Error getting traceback - " ## what ## ">";goto done;}
+#endif
 char *GetPythonTraceback(PyObject *exc_type, PyObject *exc_value, PyObject *exc_tb)
 {
 	// Sleep (30000); // Time enough to attach the debugger (barely)
diff --git a/win32/src/PythonService.cpp b/win32/src/PythonService.cpp
index c7b7531..8a9121d 100644
--- a/win32/src/PythonService.cpp
+++ b/win32/src/PythonService.cpp
@@ -302,7 +302,11 @@ static PyObject *PySetEventSourceName(PyObject *self, PyObject *args)
 	if (!PyWinObject_AsTCHAR(obName, &msg))
 		return NULL;
 	_tcsncpy(g_szEventSourceName, msg,
+#if defined(__MINGW32__)
+			 sizeof(g_szEventSourceName)/sizeof(TCHAR));
+#else
 			 sizeof g_szEventSourceName/sizeof TCHAR);
+#endif
 	PyWinObject_FreeTCHAR(msg);
 	g_bRegisteredEventSource = FALSE; // so this name re-registered.
 	if (registerNow)
@@ -680,10 +684,18 @@ BOOL PythonService_Initialize( const TCHAR *evtsrc_name, const TCHAR *evtsrc_fil
 {
 	if (evtsrc_name && *evtsrc_name)
 		_tcsncpy(g_szEventSourceName, evtsrc_name,
+#if defined(__MINGW32__)
+				 sizeof(g_szEventSourceName)/sizeof(TCHAR));
+#else
 				 sizeof g_szEventSourceName/sizeof TCHAR);
+#endif
 	if (evtsrc_file && *evtsrc_file)
 		_tcsncpy(g_szEventSourceFileName, evtsrc_file,
+#if defined(__MINGW32__)
+				 sizeof(g_szEventSourceFileName)/sizeof(TCHAR));
+#else
 				 sizeof g_szEventSourceFileName/sizeof TCHAR);
+#endif
 	return TRUE;
 }
 
@@ -1443,7 +1455,11 @@ static void CheckRegisterEventSourceFile()
 
 	if (!g_szEventSourceFileName[0])
 		GetModuleFileName(g_hdll, g_szEventSourceFileName,
+#if defined(__MINGW32__)
+		                  sizeof(g_szEventSourceFileName)/sizeof(TCHAR));
+#else
 		                  sizeof g_szEventSourceFileName/sizeof TCHAR);
+#endif
 
 	HKEY hkey;
 	TCHAR keyName[MAX_PATH];
@@ -1549,7 +1565,11 @@ BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
 #else // PYSERVICE_BUILD_DLL
 // Our EXE entry point.
 
+#if defined(__MINGW32__)
+extern "C" int main(int argc, TCHAR **argv)
+#else
 int _tmain(int argc, TCHAR **argv)
+#endif
 {
 	PyObject *module, *f;
 	PyThreadState *threadState;
diff --git a/win32/src/PythonServiceMessages.mc b/win32/src/PythonServiceMessages.mc
index ef26675..c8787a4 100644
--- a/win32/src/PythonServiceMessages.mc
+++ b/win32/src/PythonServiceMessages.mc
@@ -134,6 +134,7 @@ MessageId=0x7
 Severity=Error
 SymbolicName=E_UNUSED2
 Language=English
+%1
 .
 
 MessageId=0x8
diff --git a/win32/src/odbc.cpp b/win32/src/odbc.cpp
index c58aef5..9d3dc35 100644
--- a/win32/src/odbc.cpp
+++ b/win32/src/odbc.cpp
@@ -18,6 +18,10 @@
 #include "PyWinObjects.h"
 #include "structmember.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
+
 #include <sql.h>
 #include <sqlext.h>
 
@@ -105,96 +109,10 @@ static cursorObject *cursor(PyObject *o)
 }
 
 static void cursorDealloc(PyObject *self);
-PyMethodDef cursorMethods[];
-PyMemberDef cursorMembers[];
 
-static PyTypeObject Cursor_Type =
-{
-	PYWIN_OBJECT_HEAD
-	"odbccur",				/*tp_name */
-	sizeof(cursorObject),	/*tp_basicsize */
-	0,						/*tp_itemsize */
-	cursorDealloc,			/*tp_dealloc */
-	0,						/*tp_print */
-	0,						/*tp_getattr */
-	0,						/*tp_setattr */
-	0,						/*tp_compare */
-	0,						/*tp_repr */
-	0,						/*tp_as_number */
-	0,						/* tp_as_sequence */
-	0,						/* tp_as_mapping */
-	0,						/* tp_hash */
-	0,						/* tp_call */
-	0,						/*tp_str */
-	PyObject_GenericGetAttr,	/* tp_getattro dbiGetAttr */
-	PyObject_GenericSetAttr,	/* tp_setattro */
-	0,						/*tp_as_buffer*/
-	Py_TPFLAGS_DEFAULT,		/* tp_flags */
-	0,						/* tp_doc */
-	0,						/* tp_traverse */
-	0,						/* tp_clear */
-	0,						/* tp_richcompare */
-	0,						/* tp_weaklistoffset */
-	0,						/* tp_iter */
-	0,						/* tp_iternext */
-	cursorMethods,			/* tp_methods */
-	cursorMembers,			/* tp_members */
-	0,						/* tp_getset */
-	0,						/* tp_base */
-	0,						/* tp_dict */
-	0,						/* tp_descr_get */
-	0,						/* tp_descr_set */
-	0,						/* tp_dictoffset */
-	0,						/* tp_init */
-	0,						/* tp_alloc */
-	0,						/* tp_new */
-};
 
 
 static void connectionDealloc(PyObject *self);
-PyMethodDef connectionMethods[];
-PyMemberDef connectionMembers[];
-static PyTypeObject Connection_Type =
-{
-	PYWIN_OBJECT_HEAD
-	"odbcconn",				/*tp_name */
-	sizeof (connectionObject),	/*tp_basicsize */
-	0,						/*tp_itemsize */
-	connectionDealloc,		/*tp_dealloc */
-	0,						/*tp_print */
-	0,						/*tp_getattr */
-	0,						/*tp_setattr */
-	0,						/*tp_compare */
-	0,						/*tp_repr */
-	0,						/*tp_as_number */
-	0,						/* tp_as_sequence */
-	0,						/* tp_as_mapping */
-	0,						/* tp_hash */
-	0,						/* tp_call */
-	0,						/*tp_str */
-	PyObject_GenericGetAttr,	/* tp_getattro dbiGetAttr */
-	PyObject_GenericSetAttr,	/* tp_setattro */
-	0,						/*tp_as_buffer*/
-	Py_TPFLAGS_DEFAULT,		/* tp_flags */
-	0,						/* tp_doc */
-	0,						/* tp_traverse */
-	0,						/* tp_clear */
-	0,						/* tp_richcompare */
-	0,						/* tp_weaklistoffset */
-	0,						/* tp_iter */
-	0,						/* tp_iternext */
-	connectionMethods,		/* tp_methods */
-	connectionMembers,		/* tp_members */
-	0,						/* tp_getset */
-	0,						/* tp_base */
-	0,						/* tp_dict */
-	0,						/* tp_descr_get */
-	0,						/* tp_descr_set */
-	0,						/* tp_dictoffset */
-	0,						/* tp_init */
-	0,						/* tp_alloc */
-	0,						/* tp_new */
-};
 
 static int unsuccessful(RETCODE rc)
 {
@@ -334,144 +252,6 @@ static int attemptReconnect(cursorObject *cur)
 }
 
 
-/* @pymethod |connection|setautocommit|Sets the autocommit mode. */
-static PyObject *odbcSetAutoCommit(PyObject *self, PyObject *args)
-{
-	int c;
-	connectionObject *conn;
-	/* @pyparm int|c||The boolean autocommit mode. */
-	if (!PyArg_ParseTuple(args, "i",&c))
-		return NULL;
-	conn=connection(self);
-	if (c==0)
-	{
-		if (unsuccessful(SQLSetConnectOption(
-			conn->hdbc,
-			SQL_AUTOCOMMIT,
-			SQL_AUTOCOMMIT_OFF)))
-		{
-			connectionError(conn, _T("SETAUTOCOMMIT"));
-			return NULL;
-		}
-	}
-	else
-	{
-		if (unsuccessful(SQLSetConnectOption(
-			conn->hdbc,
-			SQL_AUTOCOMMIT,
-			SQL_AUTOCOMMIT_ON)))
-		{
-			connectionError(conn, _T("SETAUTOCOMMIT"));
-			return NULL;
-		};
-	}
-
-	Py_INCREF(Py_None);
-	return Py_None;
-}
-
-
-/* @pymethod |connection|commit|Commits a transaction. */
-static PyObject *odbcCommit(PyObject *self, PyObject *args)
-{
-	RETCODE rc;
-	Py_BEGIN_ALLOW_THREADS
-	rc = SQLTransact(
-		Env,
-		connection(self)->hdbc,
-		SQL_COMMIT);
-	Py_END_ALLOW_THREADS
-	if (unsuccessful(rc))
-	{
-		connectionError(connection(self), _T("COMMIT"));
-		return 0;
-	}
-	else
-	{
-		Py_INCREF(Py_None);
-		return Py_None;
-	}
-}
-
-/* @pymethod |connection|rollback|Rollsback a transaction. */
-static PyObject *odbcRollback(PyObject *self, PyObject *args)
-{
-	RETCODE rc;
-	Py_BEGIN_ALLOW_THREADS
-	rc = SQLTransact(
-		Env,
-		connection(self)->hdbc,
-		SQL_ROLLBACK);
-	Py_END_ALLOW_THREADS
-	if (unsuccessful(rc))
-	{
-		connectionError(connection(self), _T("ROLLBACK"));
-		return 0;
-	}
-	else {
-		Py_INCREF(Py_None);
-		return Py_None;
-	}
-}
-
-/* @pymethod |connection|cursor|Creates a <o cursor> object */
-static PyObject *odbcCursor(PyObject *self, PyObject *args)
-{
-	connectionObject *conn = connection(self);
-	if (conn->connected == 0)
-	{
-		if (doConnect(conn))
-		{
-			return 0;
-		}
-	}
-
-	cursorObject *cur = PyObject_New(cursorObject, &Cursor_Type);
-	if (cur == NULL)
-		return NULL;
-
-	cur->outputVars = 0;
-	cur->inputVars = 0;
-	cur->description = 0;
-	cur->max_width = 65536L;
-	cur->my_conx = 0;
-	cur->hstmt=NULL;
-	cur->cursorError=odbcError;
-	Py_INCREF(odbcError);
-	if (unsuccessful(SQLAllocStmt(conn->hdbc, &cur->hstmt)))
-	{
-		connectionError(cur->my_conx, _T("OPEN"));
-		Py_DECREF(cur);
-		return NULL;
-	}
-	cur->my_conx = conn;
-	cur->connect_id = cur->my_conx->connect_id;
-	Py_INCREF(self); /* the cursors owns a reference to the connection */
-	return (PyObject*) cur;
-}
-
-/* @pymethod |connection|close|Closes the connection. */
-static PyObject *odbcClose(PyObject *self, PyObject *args)
-{
-  Py_INCREF(Py_None);
-  return Py_None;
-}
-
-/* @object connection|An object representing an ODBC connection */
-static struct PyMethodDef connectionMethods[] = {
-	{ "setautocommit", odbcSetAutoCommit, 1 }, /* @pymeth setautocommit|Sets the autocommit mode. */
-	{ "commit", odbcCommit, 1 } , /* @pymeth commit|Commits a transaction. */
-	{ "rollback", odbcRollback, 1 } , /* @pymeth rollback|Rollsback a transaction. */
-	{ "cursor", odbcCursor, 1 } , /* @pymeth cursor|Creates a <o cursor> object */
-	{ "close", odbcClose, 1 } , /* @pymeth close|Closes the connection. */
-	{0,     0}
-};
-
-static PyMemberDef connectionMembers[] = {
-	{"error", T_OBJECT, offsetof(connectionObject, connectionError), READONLY},
-	{NULL}
-};
-
 static void connectionDealloc(PyObject *self)
 {
 	Py_XDECREF(connection(self)->connectionError);
@@ -1192,21 +972,41 @@ static int display_size(short coltype, int collen, const TCHAR *colname)
     case SQL_DATE:
     case SQL_TIMESTAMP:
     case SQL_BIT:
+#if defined(__MINGW32__)
+      return(std::max(collen, (int)_tcslen(colname)));
+#else
       return(max(collen, (int)_tcslen(colname)));
+#endif
     case SQL_SMALLINT:
     case SQL_INTEGER:
     case SQL_TINYINT:
+#if defined(__MINGW32__)
+      return(std::max(collen+1, (int)_tcslen(colname)));
+#else
       return(max(collen+1, (int)_tcslen(colname)));
+#endif
     case SQL_DECIMAL:
     case SQL_NUMERIC:
+#if defined(__MINGW32__)
+      return(std::max(collen+2, (int)_tcslen(colname)));
+#else
       return(max(collen+2, (int)_tcslen(colname)));
+#endif
     case SQL_REAL:
     case SQL_FLOAT:
     case SQL_DOUBLE:
+#if defined(__MINGW32__)
+      return(std::max(20, (int)_tcslen(colname)));
+#else
       return(max(20, (int)_tcslen(colname)));
+#endif
     case SQL_BINARY:
     case SQL_VARBINARY:
+#if defined(__MINGW32__)
+      return(std::max(2*collen, (int)_tcslen(colname)));
+#else
       return(max(2*collen, (int)_tcslen(colname)));
+#endif
     case SQL_LONGVARBINARY:
     case SQL_LONGVARCHAR:
     default:
@@ -1814,6 +1614,226 @@ static PyMemberDef cursorMembers[] = {
 	{NULL}
 };
 
+static PyTypeObject Cursor_Type =
+{
+	PYWIN_OBJECT_HEAD
+	"odbccur",				/*tp_name */
+	sizeof(cursorObject),	/*tp_basicsize */
+	0,						/*tp_itemsize */
+	cursorDealloc,			/*tp_dealloc */
+	0,						/*tp_print */
+	0,						/*tp_getattr */
+	0,						/*tp_setattr */
+	0,						/*tp_compare */
+	0,						/*tp_repr */
+	0,						/*tp_as_number */
+	0,						/* tp_as_sequence */
+	0,						/* tp_as_mapping */
+	0,						/* tp_hash */
+	0,						/* tp_call */
+	0,						/*tp_str */
+	PyObject_GenericGetAttr,	/* tp_getattro dbiGetAttr */
+	PyObject_GenericSetAttr,	/* tp_setattro */
+	0,						/*tp_as_buffer*/
+	Py_TPFLAGS_DEFAULT,		/* tp_flags */
+	0,						/* tp_doc */
+	0,						/* tp_traverse */
+	0,						/* tp_clear */
+	0,						/* tp_richcompare */
+	0,						/* tp_weaklistoffset */
+	0,						/* tp_iter */
+	0,						/* tp_iternext */
+	cursorMethods,			/* tp_methods */
+	cursorMembers,			/* tp_members */
+	0,						/* tp_getset */
+	0,						/* tp_base */
+	0,						/* tp_dict */
+	0,						/* tp_descr_get */
+	0,						/* tp_descr_set */
+	0,						/* tp_dictoffset */
+	0,						/* tp_init */
+	0,						/* tp_alloc */
+	0,						/* tp_new */
+};
+/* @pymethod |connection|setautocommit|Sets the autocommit mode. */
+static PyObject *odbcSetAutoCommit(PyObject *self, PyObject *args)
+{
+	int c;
+	connectionObject *conn;
+	/* @pyparm int|c||The boolean autocommit mode. */
+	if (!PyArg_ParseTuple(args, "i",&c))
+		return NULL;
+	conn=connection(self);
+	if (c==0)
+	{
+		if (unsuccessful(SQLSetConnectOption(
+			conn->hdbc,
+			SQL_AUTOCOMMIT,
+			SQL_AUTOCOMMIT_OFF)))
+		{
+			connectionError(conn, _T("SETAUTOCOMMIT"));
+			return NULL;
+		}
+	}
+	else
+	{
+		if (unsuccessful(SQLSetConnectOption(
+			conn->hdbc,
+			SQL_AUTOCOMMIT,
+			SQL_AUTOCOMMIT_ON)))
+		{
+			connectionError(conn, _T("SETAUTOCOMMIT"));
+			return NULL;
+		};
+	}
+
+	Py_INCREF(Py_None);
+	return Py_None;
+}
+
+
+/* @pymethod |connection|commit|Commits a transaction. */
+static PyObject *odbcCommit(PyObject *self, PyObject *args)
+{
+	RETCODE rc;
+	Py_BEGIN_ALLOW_THREADS
+	rc = SQLTransact(
+		Env,
+		connection(self)->hdbc,
+		SQL_COMMIT);
+	Py_END_ALLOW_THREADS
+	if (unsuccessful(rc))
+	{
+		connectionError(connection(self), _T("COMMIT"));
+		return 0;
+	}
+	else
+	{
+		Py_INCREF(Py_None);
+		return Py_None;
+	}
+}
+
+/* @pymethod |connection|rollback|Rollsback a transaction. */
+static PyObject *odbcRollback(PyObject *self, PyObject *args)
+{
+	RETCODE rc;
+	Py_BEGIN_ALLOW_THREADS
+	rc = SQLTransact(
+		Env,
+		connection(self)->hdbc,
+		SQL_ROLLBACK);
+	Py_END_ALLOW_THREADS
+	if (unsuccessful(rc))
+	{
+		connectionError(connection(self), _T("ROLLBACK"));
+		return 0;
+	}
+	else {
+		Py_INCREF(Py_None);
+		return Py_None;
+	}
+}
+
+/* @pymethod |connection|cursor|Creates a <o cursor> object */
+static PyObject *odbcCursor(PyObject *self, PyObject *args)
+{
+	connectionObject *conn = connection(self);
+	if (conn->connected == 0)
+	{
+		if (doConnect(conn))
+		{
+			return 0;
+		}
+	}
+
+	cursorObject *cur = PyObject_New(cursorObject, &Cursor_Type);
+	if (cur == NULL)
+		return NULL;
+
+	cur->outputVars = 0;
+	cur->inputVars = 0;
+	cur->description = 0;
+	cur->max_width = 65536L;
+	cur->my_conx = 0;
+	cur->hstmt=NULL;
+	cur->cursorError=odbcError;
+	Py_INCREF(odbcError);
+	if (unsuccessful(SQLAllocStmt(conn->hdbc, &cur->hstmt)))
+	{
+		connectionError(cur->my_conx, _T("OPEN"));
+		Py_DECREF(cur);
+		return NULL;
+	}
+	cur->my_conx = conn;
+	cur->connect_id = cur->my_conx->connect_id;
+	Py_INCREF(self); /* the cursors owns a reference to the connection */
+	return (PyObject*) cur;
+}
+
+/* @pymethod |connection|close|Closes the connection. */
+static PyObject *odbcClose(PyObject *self, PyObject *args)
+{
+  Py_INCREF(Py_None);
+  return Py_None;
+}
+
+/* @object connection|An object representing an ODBC connection */
+static struct PyMethodDef connectionMethods[6] = {
+	{ "setautocommit", odbcSetAutoCommit, 1 }, /* @pymeth setautocommit|Sets the autocommit mode. */
+	{ "commit", odbcCommit, 1 } , /* @pymeth commit|Commits a transaction. */
+	{ "rollback", odbcRollback, 1 } , /* @pymeth rollback|Rollsback a transaction. */
+	{ "cursor", odbcCursor, 1 } , /* @pymeth cursor|Creates a <o cursor> object */
+	{ "close", odbcClose, 1 } , /* @pymeth close|Closes the connection. */
+	{0,     0}
+};
+
+static PyMemberDef connectionMembers[2] = {
+	{"error", T_OBJECT, offsetof(connectionObject, connectionError), READONLY},
+	{NULL}
+};
+
+static PyTypeObject Connection_Type =
+{
+	PYWIN_OBJECT_HEAD
+	"odbcconn",				/*tp_name */
+	sizeof (connectionObject),	/*tp_basicsize */
+	0,						/*tp_itemsize */
+	connectionDealloc,		/*tp_dealloc */
+	0,						/*tp_print */
+	0,						/*tp_getattr */
+	0,						/*tp_setattr */
+	0,						/*tp_compare */
+	0,						/*tp_repr */
+	0,						/*tp_as_number */
+	0,						/* tp_as_sequence */
+	0,						/* tp_as_mapping */
+	0,						/* tp_hash */
+	0,						/* tp_call */
+	0,						/*tp_str */
+	PyObject_GenericGetAttr,	/* tp_getattro dbiGetAttr */
+	PyObject_GenericSetAttr,	/* tp_setattro */
+	0,						/*tp_as_buffer*/
+	Py_TPFLAGS_DEFAULT,		/* tp_flags */
+	0,						/* tp_doc */
+	0,						/* tp_traverse */
+	0,						/* tp_clear */
+	0,						/* tp_richcompare */
+	0,						/* tp_weaklistoffset */
+	0,						/* tp_iter */
+	0,						/* tp_iternext */
+	connectionMethods,		/* tp_methods */
+	connectionMembers,		/* tp_members */
+	0,						/* tp_getset */
+	0,						/* tp_base */
+	0,						/* tp_dict */
+	0,						/* tp_descr_get */
+	0,						/* tp_descr_set */
+	0,						/* tp_dictoffset */
+	0,						/* tp_init */
+	0,						/* tp_alloc */
+	0,						/* tp_new */
+};
 static void parseInfo(connectionObject *conn, const TCHAR *c)
 {
 	TCHAR *p;
diff --git a/win32/src/win32apimodule.cpp b/win32/src/win32apimodule.cpp
index f7e36b1..dd5223f 100644
--- a/win32/src/win32apimodule.cpp
+++ b/win32/src/win32apimodule.cpp
@@ -817,12 +817,16 @@ PyFormatMessageA(PyObject *self, PyObject *args)
 	
 	{
 	PyW32_BEGIN_ALLOW_THREADS
+#if !defined(__MINGW32__)
 	__try{
+#endif
 		lrc = ::FormatMessageA(flags, pSource, msgId, langId, (LPSTR)&resultBuf, 0, (va_list *)pInserts );
+#if !defined(__MINGW32__)
 		}
 	__except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH){
 		baccessviolation=TRUE;
 		}
+#endif
 	PyW32_END_ALLOW_THREADS
 	}
 
@@ -927,12 +931,16 @@ PyFormatMessageW(PyObject *self, PyObject *args)
 
 	{
 	PyW32_BEGIN_ALLOW_THREADS
+#if !defined(__MINGW32__)
 	__try{
+#endif
 		lrc = ::FormatMessageW(flags, pSource, msgId, langId, (LPWSTR)&resultBuf, 0, (va_list *)pInserts );
+#if !defined(__MINGW32__)
 		}
 	__except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH){
 		baccessviolation=TRUE;
 		}
+#endif 
 	PyW32_END_ALLOW_THREADS
 	}
 
@@ -5774,8 +5782,11 @@ static PyObject *PyApply(PyObject *self, PyObject *args)
 	}
 	PyThreadState *stateSave = PyThreadState_Swap(NULL);
 	PyThreadState_Swap(stateSave);
+#if !defined(__MINGW32__)
 	_try {
+#endif
 		ret = PyObject_CallObject(obFunc, obArgs);
+#if !defined(__MINGW32__)
 	}
 	_except( PyApplyExceptionFilter( GetExceptionCode(),
 	                                 GetExceptionInformation(),
@@ -5804,6 +5815,7 @@ static PyObject *PyApply(PyObject *self, PyObject *args)
 		Py_XDECREF(exc_value);
 		ret = NULL;
 	}
+#endif
 	return ret;
 // @comm Calls the specified function in a manner similar to 
 // the built-in function apply(), but allows Win32 exceptions
diff --git a/win32/src/win32crypt/PyCRYPTPROV.cpp b/win32/src/win32crypt/PyCRYPTPROV.cpp
index 140ddd3..3de895c 100644
--- a/win32/src/win32crypt/PyCRYPTPROV.cpp
+++ b/win32/src/win32crypt/PyCRYPTPROV.cpp
@@ -1,6 +1,10 @@
 // @doc
 #include "win32crypt.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
+
 // @object PyCRYPTPROV|Handle to a cryptographic provider, created using <om cryptoapi.CryptAcquireContext>
 struct PyMethodDef PyCRYPTPROV::methods[] = {
 	// @pymeth CryptReleaseContext|Releases the CSP handle
@@ -351,7 +355,11 @@ PyObject *PyCRYPTPROV::PyCryptGenRandom(PyObject *self, PyObject *args, PyObject
 	//initialize buffer with char string if passed if
 	ZeroMemory(pbBuffer, dwLen+1);
 	if (seeddata != NULL)
+#if defined(__MINGW32__)
+		memcpy(pbBuffer, seeddata, std::min(dwLen,seedlen));
+#else
 		memcpy(pbBuffer, seeddata, min(dwLen,seedlen));
+#endif
 	if (CryptGenRandom(hcryptprov, dwLen, pbBuffer))
 		ret=PyString_FromStringAndSize((char *)pbBuffer, dwLen);
 	else
diff --git a/win32/src/win32crypt/win32cryptmodule.cpp b/win32/src/win32crypt/win32cryptmodule.cpp
index 29b2c80..5875294 100644
--- a/win32/src/win32crypt/win32cryptmodule.cpp
+++ b/win32/src/win32crypt/win32cryptmodule.cpp
@@ -597,34 +597,59 @@ static PyObject *PyCertOpenStore(PyObject *self, PyObject *args, PyObject *kwarg
 		}
 	else{
 		switch((ULONG_PTR)StoreProvider){
+#if defined(__MINGW32__)
+			case (ULONG_PTR)14:
+			case (ULONG_PTR)8:
+			case (ULONG_PTR)10:
+			case (ULONG_PTR)13:
+			case (ULONG_PTR)16:{
+#else
 			case CERT_STORE_PROV_PHYSICAL:
 			case CERT_STORE_PROV_FILENAME:
 			case CERT_STORE_PROV_SYSTEM:
 			case CERT_STORE_PROV_SYSTEM_REGISTRY:
 			case CERT_STORE_PROV_LDAP:{
+#endif
 				if (!PyWinObject_AsWCHAR(obpvPara, (WCHAR **)&pvPara))
 					return NULL;
 				free_wchar=TRUE;
 				break;
 				}
+#if defined(__MINGW32__)
+			case (ULONG_PTR)4:{
+#else
 			case CERT_STORE_PROV_REG:{
+#endif
 				if (!PyWinObject_AsHKEY(obpvPara, (HKEY *)&pvPara))
 					return NULL;
 				break;
 				}
+#if defined(__MINGW32__)
+			case (ULONG_PTR)3:{
+#else
 			case CERT_STORE_PROV_FILE:{
+#endif
 				if (!PyWinObject_AsHANDLE(obpvPara, (HANDLE *)&pvPara))
 					return NULL;
 				break;
 				}
+#if defined(__MINGW32__)
+			case (ULONG_PTR)6:
+			case (ULONG_PTR)5:{
+#else
 			case CERT_STORE_PROV_SERIALIZED:
 			case CERT_STORE_PROV_PKCS7:{
+#endif
 				if (!PyWinObject_AsReadBuffer(obpvPara, (void **)&crypt_data_blob.pbData, &crypt_data_blob.cbData))
 					return NULL;
 				pvPara=(void *)&crypt_data_blob;
 				break;
 				}
+#if defined(__MINGW32__)
+			case (ULONG_PTR)2:{
+#else
 			case CERT_STORE_PROV_MEMORY:{
+#endif
 				// pvPara is not used, warn if something passed in
 				if (obpvPara != Py_None)
 					PyErr_Warn(PyExc_RuntimeWarning, "Para ignored for CERT_STORE_PROV_MEMORY");
diff --git a/win32/src/win32evtlog.i b/win32/src/win32evtlog.i
index 847230c..142923b 100644
--- a/win32/src/win32evtlog.i
+++ b/win32/src/win32evtlog.i
@@ -1012,11 +1012,15 @@ PyCFunction pfnPyEvtUpdateBookmark = (PyCFunction) PyEvtUpdateBookmark;
 
 PyObject *PyWinObject_FromEVT_VARIANT(PEVT_VARIANT val)
 {
+#if defined(__MINGW32__)
+	DWORD val_type = val->Type;
+#else
 	if (val->Type & EVT_VARIANT_TYPE_ARRAY){
 		PyErr_SetString(PyExc_NotImplementedError, "EVT_VARIANT arrays not supported yet");
 		return NULL;
 		}
 	DWORD val_type = val->Type & EVT_VARIANT_TYPE_MASK;
+#endif
 	PyObject *obval = NULL;
 	switch (val_type){
 		case EvtVarTypeNull:
diff --git a/win32/src/win32file.i b/win32/src/win32file.i
index 2b82d37..39e7cd1 100644
--- a/win32/src/win32file.i
+++ b/win32/src/win32file.i
@@ -1420,11 +1420,19 @@ static PyObject *PyObject_FromFILE_NOTIFY_INFORMATION(void *buffer, DWORD nbytes
 	// the filename is exactly 1 byte!  Not clear the best way to
 	// check this, but this works for now - is it at least the size of
 	// the *head* of the struct.
+#if defined(__MINGW32__)
+	if (nbytes < sizeof(DWORD)*3+2)
+#else
 	if (nbytes < sizeof DWORD*3+2)
+#endif
 		return ret;
 	DWORD nbytes_read = 0;
 	while (1) {
+#if defined(__MINGW32__)
+                PyObject *fname = PyWinObject_FromOLECHAR(p->FileName, p->FileNameLength/sizeof(WCHAR));
+#else
 		PyObject *fname = PyWinObject_FromOLECHAR(p->FileName, p->FileNameLength/sizeof WCHAR);
+#endif
 		if (!fname) {
 			Py_DECREF(ret);
 			return NULL;
diff --git a/win32/src/win32file_comm.cpp b/win32/src/win32file_comm.cpp
index 19f2eb7..d16fb76 100644
--- a/win32/src/win32file_comm.cpp
+++ b/win32/src/win32file_comm.cpp
@@ -173,11 +173,19 @@ PyDCB::~PyDCB(void)
 {
 }
 
+#if defined(__MINGW32__)
+#define GET_BITFIELD_ENTRY(bitfield_name) \
+	else if (strcmp(name, #bitfield_name)==0) { \
+		return PyInt_FromLong(pydcb->m_DCB. bitfield_name); \
+	} \
+
+#else
 #define GET_BITFIELD_ENTRY(bitfield_name) \
 	else if (strcmp(name, #bitfield_name)==0) { \
 		return PyInt_FromLong(pydcb->m_DCB.##bitfield_name); \
 	} \
 
+#endif
 PyObject *PyDCB::getattro(PyObject *self, PyObject *obname)
 {
 	PyDCB *pydcb = (PyDCB *)self;
@@ -204,7 +212,19 @@ PyObject *PyDCB::getattro(PyObject *self, PyObject *obname)
 	return PyObject_GenericGetAttr(self, obname);
 }
 
+#if defined(__MINGW32__)
 #define SET_BITFIELD_ENTRY(bitfield_name) \
+	else if (strcmp(name, #bitfield_name)==0) { \
+		if (!PyInt_Check(v)) { \
+			PyErr_Format(PyExc_TypeError, szNeedIntAttr, #bitfield_name); \
+			return -1; \
+		} \
+		pydcb->m_DCB. bitfield_name = PyInt_AsLong(v); \
+		return 0; \
+	} \
+
+#else
+#define SET_BITFIELD_ENTRY(bitfield_name)           \
 	else if (strcmp(name, #bitfield_name)==0) { \
 		if (!PyInt_Check(v)) { \
 			PyErr_Format(PyExc_TypeError, szNeedIntAttr, #bitfield_name); \
@@ -214,6 +234,7 @@ PyObject *PyDCB::getattro(PyObject *self, PyObject *obname)
 		return 0; \
 	} \
 
+#endif
 int PyDCB::setattro(PyObject *self, PyObject *obname, PyObject *v)
 {
 	PyDCB *pydcb = (PyDCB *)self;
@@ -367,11 +388,19 @@ PyCOMSTAT::~PyCOMSTAT(void)
 }
 
 #undef GET_BITFIELD_ENTRY
+#if defined(__MINGW32__)
+#define GET_BITFIELD_ENTRY(bitfield_name) \
+	else if (strcmp(name, #bitfield_name)==0) { \
+		return PyInt_FromLong(pyCOMSTAT->m_COMSTAT. bitfield_name); \
+	} \
+
+#else
 #define GET_BITFIELD_ENTRY(bitfield_name) \
 	else if (strcmp(name, #bitfield_name)==0) { \
 		return PyInt_FromLong(pyCOMSTAT->m_COMSTAT.##bitfield_name); \
 	} \
 
+#endif
 PyObject *PyCOMSTAT::getattro(PyObject *self, PyObject *obname)
 {
 	PyCOMSTAT *pyCOMSTAT = (PyCOMSTAT *)self;
@@ -392,6 +421,18 @@ PyObject *PyCOMSTAT::getattro(PyObject *self, PyObject *obname)
 }
 
 #undef SET_BITFIELD_ENTRY
+#if defined(__MINGW32__)
+#define SET_BITFIELD_ENTRY(bitfield_name) \
+	else if (strcmp(name, #bitfield_name)==0) { \
+		if (!PyInt_Check(v)) { \
+			PyErr_Format(PyExc_TypeError, szNeedIntAttr, #bitfield_name); \
+			return -1; \
+		} \
+		pyCOMSTAT->m_COMSTAT. bitfield_name = PyInt_AsLong(v); \
+		return 0; \
+	} \
+
+#else
 #define SET_BITFIELD_ENTRY(bitfield_name) \
 	else if (strcmp(name, #bitfield_name)==0) { \
 		if (!PyInt_Check(v)) { \
@@ -402,6 +443,7 @@ PyObject *PyCOMSTAT::getattro(PyObject *self, PyObject *obname)
 		return 0; \
 	} \
 
+#endif
 int PyCOMSTAT::setattro(PyObject *self, PyObject *obname, PyObject *v)
 {
 	PyCOMSTAT *pyCOMSTAT = (PyCOMSTAT *)self;
diff --git a/win32/src/win32gui.i b/win32/src/win32gui.i
index 94b738f..bc5e494 100644
--- a/win32/src/win32gui.i
+++ b/win32/src/win32gui.i
@@ -34,6 +34,9 @@
 #include "Dbt.h" // device notification
 #include "malloc.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
 #ifdef MS_WINCE
 #include "winbase.h"
 #define IS_INTRESOURCE(res) (((DWORD)(res) & 0xffff0000) == 0)
@@ -640,7 +643,11 @@ typedef int UINT;
 // @object TRACKMOUSEEVENT|A tuple of (dwFlags, hwndTrack, dwHoverTime)
 %typemap(python,in) TRACKMOUSEEVENT *INPUT(TRACKMOUSEEVENT e){
 	PyObject *obhwnd;
+#if defined(__MINGW32__)
+	e.cbSize = sizeof(e);
+#else
 	e.cbSize = sizeof e;
+#endif
 	if (PyTuple_Check($source)) {
 		if (PyArg_ParseTuple($source, "lOl", &e.dwFlags, &obhwnd, &e.dwHoverTime) == 0) {
 			return PyErr_Format(PyExc_TypeError, "%s: a TRACKMOUSEEVENT must be a tuple of 3 integers", "$name");
@@ -1822,7 +1829,11 @@ PyObject *PyFlashWindowEx(PyObject *self, PyObject *args)
 	PyObject *ret, *obhwnd;
 	BOOL rc;
 	FLASHWINFO f;
+#if defined(__MINGW32__)
+	f.cbSize = sizeof(f);
+#else
 	f.cbSize = sizeof f;
+#endif
 	// @pyparm <o PyHANDLE>|hwnd||Handle to a window
 	// @pyparm int|dwFlags||Combination of win32con.FLASHW_* flags
 	// @pyparm int|uCount||Nbr of times to flash
@@ -3802,7 +3813,11 @@ static PyObject *PyExtractIconEx(PyObject *self, PyObject *args)
     nicons_got = 1;
 #endif
     // Asking for 1 always says it got 2!?
+#if defined(__MINGW32__)
+    nicons = std::min(nicons, nicons_got);
+#else
     nicons = min(nicons, nicons_got);
+#endif
     objects_large = PyList_New(nicons);
     if (!objects_large) goto done;
     objects_small = PyList_New(nicons);
@@ -4596,29 +4611,49 @@ BOOL GetOpenFileName(OPENFILENAME *INPUT);
 %typemap (python, in) MENUITEMINFO *INPUT (Py_ssize_t target_size){
 	if (0 != PyObject_AsReadBuffer($source, (const void **)&$target, &target_size))
 		return NULL;
+#if defined(__MINGW32__)
+	if (sizeof(MENUITEMINFO) != target_size)
+		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte string/buffer (got %d bytes)", sizeof(MENUITEMINFO), target_size);
+#else
 	if (sizeof MENUITEMINFO != target_size)
 		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte string/buffer (got %d bytes)", sizeof MENUITEMINFO, target_size);
+#endif
 }
 
 %typemap (python,in) MENUITEMINFO *BOTH(Py_ssize_t target_size) {
 	if (0 != PyObject_AsWriteBuffer($source, (void **)&$target, &target_size))
 		return NULL;
+#if defined(__MINGW32__)
+	if (sizeof(MENUITEMINFO) != target_size)
+		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte buffer (got %d bytes)", sizeof(MENUITEMINFO), target_size);
+#else
 	if (sizeof MENUITEMINFO != target_size)
 		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte buffer (got %d bytes)", sizeof MENUITEMINFO, target_size);
+#endif
 }
 
 %typemap (python, in) MENUINFO *INPUT (Py_ssize_t target_size){
 	if (0 != PyObject_AsReadBuffer($source, (const void **)&$target, &target_size))
 		return NULL;
+#if defined(__MINGW32__)
+	if (sizeof(MENUINFO) != target_size)
+		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte string/buffer (got %d bytes)", sizeof(MENUINFO), target_size);
+#else
 	if (sizeof MENUINFO != target_size)
 		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte string/buffer (got %d bytes)", sizeof MENUINFO, target_size);
+#endif
 }
 
 %typemap (python,in) MENUINFO *BOTH(Py_ssize_t target_size) {
 	if (0 != PyObject_AsWriteBuffer($source, (void **)&$target, &target_size))
 		return NULL;
+#if defined(__MINGW32__)
+	if (sizeof(MENUINFO) != target_size)
+		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte buffer (got %d bytes)", sizeof(MENUINFO), target_size);
+#else
 	if (sizeof MENUINFO != target_size)
 		return PyErr_Format(PyExc_TypeError, "Argument must be a %d-byte buffer (got %d bytes)", sizeof MENUINFO, target_size);
+#endif
 }
 
 // @pyswig |InsertMenuItem|Inserts a menu item
@@ -4750,8 +4785,13 @@ PyObject *PySetMenuInfo(PyObject *self, PyObject *args)
 
 	if (0 != PyObject_AsReadBuffer(obInfo, (const void **)&pInfo, &cbInfo))
 		return NULL;
+#if defined(__MINGW32__)
+	if (sizeof(MENUINFO) != cbInfo)
+		return PyErr_Format(PyExc_TypeError, "Argument must be a %d byte string/buffer (got %d bytes)", sizeof(MENUINFO), cbInfo);
+#else
 	if (sizeof MENUINFO != cbInfo)
 		return PyErr_Format(PyExc_TypeError, "Argument must be a %d byte string/buffer (got %d bytes)", sizeof MENUINFO, cbInfo);
+#endif
 
 	Py_BEGIN_ALLOW_THREADS
 	result = (*pfnSetMenuInfo)(hmenu, pInfo);
@@ -4787,8 +4827,13 @@ PyObject *PyGetMenuInfo(PyObject *self, PyObject *args)
 
 	if (0 != PyObject_AsWriteBuffer(obInfo, (void **)&pInfo, &cbInfo))
 		return NULL;
+#if defined(__MINGW32__)
+	if (sizeof(MENUINFO) != cbInfo)
+		return PyErr_Format(PyExc_TypeError, "Argument must be a %d byte buffer (got %d bytes)", sizeof(MENUINFO), cbInfo);
+#else
 	if (sizeof MENUINFO != cbInfo)
 		return PyErr_Format(PyExc_TypeError, "Argument must be a %d byte buffer (got %d bytes)", sizeof MENUINFO, cbInfo);
+#endif
 
 	Py_BEGIN_ALLOW_THREADS
 	result = (*pfnGetMenuInfo)(hmenu, pInfo);
@@ -6005,7 +6050,11 @@ PyGetClassName(PyObject *self, PyObject *args)
 	if (!PyWinObject_AsHANDLE(obhwnd, (HANDLE *)&hwnd))
 		return NULL;
 	// dont bother with lock - no callback possible.
+#if defined(__MINGW32__)
+	int nchars = GetClassName(hwnd, buf, sizeof(buf)/sizeof(buf[0]));
+#else
 	int nchars = GetClassName(hwnd, buf, sizeof buf/sizeof buf[0]);
+#endif
 	if (nchars==0)
 		return PyWin_SetAPIError("GetClassName");
 	return PyWinObject_FromTCHAR(buf, nchars);
@@ -6370,7 +6419,11 @@ BOOL PyParse_OPENFILENAMEW_Args(PyObject *args, PyObject *kwargs, OPENFILENAMEW
 	// lpstrFile buffer receives full path and possibly multiple file names, allocate extra space
 	if (!PyWinObject_AsWCHAR(obFile, &initfile, TRUE, &initfilechars))
 		goto done;
+#if defined(__MINGW32__)
+	pofn->nMaxFile=std::max(pofn->nMaxFile, initfilechars+1);
+#else
 	pofn->nMaxFile=max(pofn->nMaxFile, initfilechars+1);
+#endif
 	bufsize=pofn->nMaxFile*sizeof(WCHAR);
 	pofn->lpstrFile=(LPWSTR)malloc(bufsize);
 	if (pofn->lpstrFile==NULL){
@@ -7506,13 +7559,13 @@ PyObject *PyRegisterDeviceNotification(PyObject *self, PyObject *args)
 				"structure says it has %d bytes, but %d was provided",
 				(int)struct_bytes, (int)nbytes);
 	// @pyseeapi RegisterDeviceNotification
-	HDEVNOTIFY not;
+	HDEVNOTIFY notify;
 	Py_BEGIN_ALLOW_THREADS
-	not = RegisterDeviceNotification(handle, (void *)filter, flags);
+	notify = RegisterDeviceNotification(handle, (void *)filter, flags);
 	Py_END_ALLOW_THREADS
-	if (not == NULL)
+	if (notify == NULL)
 		return PyWin_SetAPIError("RegisterDeviceNotification");
-	return PyWinObject_FromHDEVNOTIFY(not);
+	return PyWinObject_FromHDEVNOTIFY(notify);
 }
 %}
 %native(RegisterDeviceNotification) PyRegisterDeviceNotification;
diff --git a/win32/src/win32inet.i b/win32/src/win32inet.i
index 92d7462..16a8912 100644
--- a/win32/src/win32inet.i
+++ b/win32/src/win32inet.i
@@ -15,6 +15,9 @@
 %{
 #undef PyHANDLE // undef earlier define, so we are back to the class.
 #include "pywinobjects.h"
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
 
 void CALLBACK PyHINTERNET_StatusChange(
 	HINTERNET hInternet,
@@ -953,8 +956,10 @@ PyObject *PyInternetQueryOption(PyObject *self, PyObject *args)
 		case INTERNET_OPTION_RECEIVE_TIMEOUT:	// @flag INTERNET_OPTION_RECEIVE_TIMEOUT|Int - timeout in millseconds
 												// @flag INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT|Int - timeout in millseconds
 		case INTERNET_OPTION_CODEPAGE:		// @flag INTERNET_OPTION_CODEPAGE|Int - Codepage of host part of URL
+#if !defined(__MINGW32__)
 		case INTERNET_OPTION_CODEPAGE_PATH:	// @flag INTERNET_OPTION_CODEPAGE_PATH|Int - Codepage for URL
 		case INTERNET_OPTION_CODEPAGE_EXTRA:	// @flag INTERNET_OPTION_CODEPAGE_EXTRA|Int - Codepage for path part of URL
+#endif
 		case INTERNET_OPTION_CONNECT_RETRIES:		// @flag INTERNET_OPTION_CONNECT_RETRIES|Int - Number of time to try to reconnect to host
 		case INTERNET_OPTION_CONNECT_TIMEOUT:		// @flag INTERNET_OPTION_CONNECT_TIMEOUT|Int - Connection timeout in milliseconds
 		case INTERNET_OPTION_CONNECTED_STATE:		// @flag INTERNET_OPTION_CONNECTED_STATE|Int - Connection state, INTERNET_STATE_*
@@ -962,7 +967,9 @@ PyObject *PyInternetQueryOption(PyObject *self, PyObject *args)
 		case INTERNET_OPTION_ERROR_MASK:		// @flag INTERNET_OPTION_ERROR_MASK|Int, combination of INTERNET_ERROR_MASK_*
 		case INTERNET_OPTION_EXTENDED_ERROR:		// @flag INTERNET_OPTION_EXTENDED_ERROR|Int, ERROR_INTERNET_*
 		case INTERNET_OPTION_FROM_CACHE_TIMEOUT:		// @flag INTERNET_OPTION_FROM_CACHE_TIMEOUT|Int - Timeout in ms before cached copy is used
+#if !defined(__MINGW32__)
 		case INTERNET_OPTION_IDN:		// @flag INTERNET_OPTION_IDN|Int, INTERNET_FLAG_IDN_*
+#endif
 		case INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER:		// @flag INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER|Int
 		case INTERNET_OPTION_MAX_CONNS_PER_SERVER:		// @flag INTERNET_OPTION_MAX_CONNS_PER_SERVER|Int
 		case INTERNET_OPTION_READ_BUFFER_SIZE:		// @flag INTERNET_OPTION_READ_BUFFER_SIZE|Int
@@ -974,7 +981,9 @@ PyObject *PyInternetQueryOption(PyObject *self, PyObject *args)
 			ret=PyLong_FromUnsignedLong(*(unsigned long *)buf);
 			break;
 		case INTERNET_OPTION_BYPASS_EDITED_ENTRY:		// @flag INTERNET_OPTION_BYPASS_EDITED_ENTRY|Boolean
+#if !defined(__MINGW32__)
 		case INTERNET_OPTION_HTTP_DECODING:		// @flag INTERNET_OPTION_HTTP_DECODING|Boolean
+#endif
 		case INTERNET_OPTION_IGNORE_OFFLINE:		// @flag INTERNET_OPTION_IGNORE_OFFLINE|Boolean
 			ret=PyBool_FromLong(*(BOOL *)buf);
 			break;
@@ -1157,14 +1166,18 @@ PyObject *PyInternetSetOption(PyObject *self, PyObject *args)
 		case INTERNET_OPTION_RECEIVE_TIMEOUT:	// @flag INTERNET_OPTION_RECEIVE_TIMEOUT|Int - timeout in millseconds
 												// @flag INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT|Int - timeout in millseconds
 		case INTERNET_OPTION_CODEPAGE:		// @flag INTERNET_OPTION_CODEPAGE|Int - Codepage of host part of URL
+#if !defined(__MINGW32__)
 		case INTERNET_OPTION_CODEPAGE_PATH:	// @flag INTERNET_OPTION_CODEPAGE_PATH|Codepage for URL
 		case INTERNET_OPTION_CODEPAGE_EXTRA:	// @flag INTERNET_OPTION_CODEPAGE_EXTRA|Int - Codepage for path part of URL
+#endif
 		case INTERNET_OPTION_CONNECT_RETRIES:		// @flag INTERNET_OPTION_CONNECT_RETRIES|Int - Number of time to try to reconnect to host
 		case INTERNET_OPTION_CONNECT_TIMEOUT:		// @flag INTERNET_OPTION_CONNECT_TIMEOUT|Int - Connection timeout in milliseconds
 		case INTERNET_OPTION_CONNECTED_STATE:		// @flag INTERNET_OPTION_CONNECTED_STATE|Int - Connection state, INTERNET_STATE_*
 		case INTERNET_OPTION_ERROR_MASK:		// @flag INTERNET_OPTION_ERROR_MASK|Int, combination of INTERNET_ERROR_MASK_*
 		case INTERNET_OPTION_FROM_CACHE_TIMEOUT:		// @flag INTERNET_OPTION_FROM_CACHE_TIMEOUT|Int - Timeout in ms before cached copy is used
+#if !defined(__MINGW32__)
 		case INTERNET_OPTION_IDN:		// @flag INTERNET_OPTION_IDN|Int, INTERNET_FLAG_IDN_*
+#endif
 		case INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER:		// @flag INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER|Int
 		case INTERNET_OPTION_MAX_CONNS_PER_SERVER:		// @flag INTERNET_OPTION_MAX_CONNS_PER_SERVER|Int
 		case INTERNET_OPTION_READ_BUFFER_SIZE:		// @flag INTERNET_OPTION_READ_BUFFER_SIZE|Int
@@ -1189,7 +1202,9 @@ PyObject *PyInternetSetOption(PyObject *self, PyObject *args)
 				}
 			break;
 		case INTERNET_OPTION_BYPASS_EDITED_ENTRY:	// @flag INTERNET_OPTION_BYPASS_EDITED_ENTRY|Boolean
+#if !defined(__MINGW32__)
 		case INTERNET_OPTION_HTTP_DECODING:		// @flag INTERNET_OPTION_HTTP_DECODING|Boolean
+#endif
 		case INTERNET_OPTION_IGNORE_OFFLINE:	// @flag INTERNET_OPTION_IGNORE_OFFLINE|Boolean
 			bufsize=sizeof(BOOL);
 			buf=malloc(bufsize);
@@ -1835,7 +1850,11 @@ BOOL PyWinObject_AsINTERNET_CACHE_GROUP_INFO(PyObject *ob, INTERNET_CACHE_GROUP_
 			}
 		}
 	if (bsuccess && GroupName)
+#if defined(__MINGW32__)
+		_tcsncpy(GroupInfo->szGroupName, GroupName, std::min(namelen, (DWORD)GROUPNAME_MAX_LENGTH));
+#else
 		_tcsncpy(GroupInfo->szGroupName, GroupName, min(namelen, GROUPNAME_MAX_LENGTH));
+#endif
 	Py_DECREF(dummy_tuple);
 	PyWinObject_FreeTCHAR(GroupName);
 	if (OwnerStorage)
diff --git a/win32/src/win32net/win32net.h b/win32/src/win32net/win32net.h
index ae7c690..c961c18 100644
--- a/win32/src/win32net/win32net.h
+++ b/win32/src/win32net/win32net.h
@@ -62,15 +62,27 @@ PyObject *PyDoGroupDelMembers(PyObject *self, PyObject *args);
 
 #if WINVER >= 0x0500
 typedef NET_API_STATUS (NET_API_FUNCTION *NetValidateNamefunc)(LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, NETSETUP_NAME_TYPE);
-extern NetValidateNamefunc pfnNetValidateName;
+extern
+#if defined(__MINGW32__)
+"C"
+#endif
+NetValidateNamefunc pfnNetValidateName;
 
 typedef NET_API_STATUS (NET_API_FUNCTION *NetGetJoinInformationfunc)(LPCWSTR, LPWSTR *, PNETSETUP_JOIN_STATUS);
 extern NetGetJoinInformationfunc pfnNetGetJoinInformation;
 
 typedef NET_API_STATUS (NET_API_FUNCTION *NetValidatePasswordPolicyfunc)(LPCWSTR, LPVOID, NET_VALIDATE_PASSWORD_TYPE, LPVOID, LPVOID *);
-extern NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy;
+extern
+#if defined(__MINGW32__)
+"C"
+#endif
+NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy;
 
 typedef NET_API_STATUS (NET_API_FUNCTION *NetValidatePasswordPolicyFreefunc)(LPVOID *);
-extern NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree;
+extern
+#if defined(__MINGW32__)
+"C"
+#endif
+NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree;
 
 #endif // WINVER
diff --git a/win32/src/win32pdhmodule.cpp b/win32/src/win32pdhmodule.cpp
index 94c4ed1..533dad7 100644
--- a/win32/src/win32pdhmodule.cpp
+++ b/win32/src/win32pdhmodule.cpp
@@ -15,6 +15,10 @@ generates Windows .hlp files.
 #include "pdh.h"
 #include "pdhmsg.h"
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
+
 /*
 According to MSDN, Pdh calls are thread safe, although there was a bug
 in Win2k that might make it appear to not be.  Plus, the PyW32* macros
@@ -1013,12 +1017,21 @@ PDH_STATUS __stdcall PyCounterPathCallback(DWORD_PTR dwArg)
 	return rc;
 }
 
+#if defined(__MINGW32__)
+#define SET_BOOL(r, i) { \
+	if (i<seqLen){ \
+		PyObject *subItem = PyTuple_GET_ITEM(flags_tuple, i); \
+		myCfg.cfg. r = PyObject_IsTrue(subItem); \
+	} \
+}
+#else
 #define SET_BOOL(r, i) { \
 	if (i<seqLen){ \
 		PyObject *subItem = PyTuple_GET_ITEM(flags_tuple, i); \
 		myCfg.cfg.##r = PyObject_IsTrue(subItem); \
 	} \
 }
+#endif
 
 // @pymethod string|win32pdh|BrowseCounters|Displays the counter browsing dialog box so that the user can select the counters to be returned to the caller. 
 static PyObject *PyBrowseCounters(PyObject *self, PyObject *args, PyObject *kwargs)
@@ -1082,7 +1095,11 @@ static PyObject *PyBrowseCounters(PyObject *self, PyObject *args, PyObject *kwar
 	// Initialize the return buffer if starting path is passed in. (bInitializePath will also be set)
 	if (!PyWinObject_AsTCHAR(obInitialPath, &InitialPath, TRUE, &cchInitialPath))
 		return NULL;	// Last exit without cleanup
+#if defined(__MINGW32__)
+	myCfg.cfg.cchReturnPathLength = std::max(cchInitialPath+1, 1024UL);
+#else
 	myCfg.cfg.cchReturnPathLength = max(cchInitialPath+1, 1024);
+#endif
 	myCfg.cfg.szReturnPathBuffer = (TCHAR *)malloc(myCfg.cfg.cchReturnPathLength * sizeof(TCHAR));
 	if (myCfg.cfg.szReturnPathBuffer == NULL){
 		PyErr_NoMemory();
diff --git a/win32/src/win32service.i b/win32/src/win32service.i
index 11a4a23..fab8092 100644
--- a/win32/src/win32service.i
+++ b/win32/src/win32service.i
@@ -1818,7 +1818,6 @@ PyObject *PyQueryServiceConfig2(PyObject *self, PyObject *args)
 #define SERVICE_CONTROL_HARDWAREPROFILECHANGE SERVICE_CONTROL_HARDWAREPROFILECHANGE
 #define SERVICE_CONTROL_POWEREVENT SERVICE_CONTROL_POWEREVENT
 #define SERVICE_CONTROL_SESSIONCHANGE SERVICE_CONTROL_SESSIONCHANGE
-#define SERVICE_CONTROL_PRESHUTDOWN SERVICE_CONTROL_PRESHUTDOWN
 
 
 #define SC_MANAGER_ALL_ACCESS SC_MANAGER_ALL_ACCESS 
@@ -1875,7 +1874,6 @@ PyObject *PyQueryServiceConfig2(PyObject *self, PyObject *args)
 #define SERVICE_ACCEPT_HARDWAREPROFILECHANGE SERVICE_ACCEPT_HARDWAREPROFILECHANGE
 #define SERVICE_ACCEPT_POWEREVENT SERVICE_ACCEPT_POWEREVENT
 #define SERVICE_ACCEPT_SESSIONCHANGE SERVICE_ACCEPT_SESSIONCHANGE
-#define SERVICE_ACCEPT_PRESHUTDOWN SERVICE_ACCEPT_PRESHUTDOWN
 
 //#define SERVICE_ERROR_IGNORER_IGNORE SERVICE_ERROR_IGNORER_IGNORE
 #define SERVICE_BOOT_START SERVICE_BOOT_START 
diff --git a/win32/src/win32trace.cpp b/win32/src/win32trace.cpp
index 2237094..60e7c83 100644
--- a/win32/src/win32trace.cpp
+++ b/win32/src/win32trace.cpp
@@ -35,6 +35,9 @@ See - I told you the implementation was simple :-)
 
 
 
+#if defined(__MINGW32__)
+#include <algorithm>
+#endif
 
 const unsigned long BUFFER_SIZE = 0x20000; // Includes size integer.
 const TCHAR *MAP_OBJECT_NAME = _T("Global\\PythonTraceOutputMapping");
@@ -341,7 +344,11 @@ BOOL PyTraceObject::WriteData(const char *data, unsigned len)
     Py_BEGIN_ALLOW_THREADS
     const char *data_this = data;
     while (len) {
+#if defined(__MINGW32__)
+        unsigned len_this = std::min(static_cast<unsigned long>(len), BUFFER_SIZE/2);
+#else
         unsigned len_this = min(len, BUFFER_SIZE/2);
+#endif
         BOOL ok = GetMyMutex();
         if (ok) {
             // must use types with identical size on win32 and win64
